var tipuesearch = {"pages":[{"text":"​","tags":"home","loc":"index.html","title":" ​ "},{"text":"Contents Modules evaluate_m Source Code evaluate.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file defines functions that perform some common matrix operations. module evaluate_m use :: math_m use :: stdio_m private ! Declare which routines to export public :: evaluate ! Declare public interfaces interface evaluate !! Public interface for various routines that evaluate mathematical expressions. module procedure evaluate_scalar_value , evaluate_scalar_field , & evaluate_vector_value , evaluate_vector_field , & evaluate_logical_value , evaluate_integer_value end interface contains impure subroutine evaluate_logical_value ( expression , value ) !! This subroutine takes a scalar logical expression as input, and returns the value. !! !! Usage: !! !!     call evaluate_logical_value('F', output) !!     call evaluate_logical_value('T', output) !! character ( * ), intent ( in ) :: expression !! Either the character 'T' or 'F' logical , intent ( out ) :: value !! Result of parsing the expression select case ( expression ) case ( 'T' , 't' ) value = . true . case ( 'F' , 'f' ) value = . false . case default call error ( 'Invalid logical expression: \"' // trim ( expression ) // '\"' ) end select end subroutine impure subroutine evaluate_integer_value ( expression , value ) !! This subroutine takes a scalar integer expression as input, and returns the value. !! !! Usage: !! !!     call evaluate_integer_value('10', output) !! character ( * ), intent ( in ) :: expression !! String containing an integer integer , intent ( out ) :: value !! Result of parsing the expression integer :: iostat !! Error status from the parsing read ( expression , * , iostat = iostat ) value if ( iostat /= 0 ) then call error ( 'Invalid integer expression: \"' // trim ( expression ) // '\"' ) end if end subroutine impure subroutine evaluate_scalar_value ( expression , value ) !! This subroutine takes a scalar mathematical expression as input, and returns the value. !! !! Usage: !! !!     call evaluate_scalar_value('0',                    output) !!     call evaluate_scalar_value('sin(0.3*pi)*exp(-pi)', output) !! use :: fparser character ( * ), intent ( in ) :: expression !! Scalar-valued mathematical expression real ( wp ), intent ( out ) :: value !! Result of parsing the expression ! Make sure the expression is non-empty if ( scan ( expression , '0123456789pi' ) <= 0 ) then call error ( 'Invalid scalar expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 1 ) call parsef ( 1 , expression , [ 'pi' ]) ! Evaluate the parsed function value = evalf ( 1 , [ pi ]) end subroutine impure subroutine evaluate_scalar_field ( expression , domain , value ) !! This subroutine takes a scalar mathematical function of some variable 'z' as input,  along !! with an array with discrete values for that variable 'z'.  It parses the provided function, !! evaluates it at each 'z'-value in the array, and then returns the discretized scalar field. !! !! Usage: !! !!     call evaluate_scalar_value('0',                    input(1:n), output(1:n)) !!     call evaluate_scalar_value('sin(pi*z)*exp(-pi*z)', input(1:n), output(1:n)) !! use :: fparser character ( * ), intent ( in ) :: expression !! Scalar-valued function of position 'z' real ( wp ), dimension (:), intent ( in ) :: domain !! Domain of the independent variable 'z' real ( wp ), dimension (:), allocatable :: value !! Result of evaluating the field at each point of the domain integer :: n ! Make sure the expression is non-empty if ( scan ( expression , '0123456789piz' ) <= 0 ) then call error ( 'Invalid scalar expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 1 ) call parsef ( 1 , expression , [ 'pi' , 'z ' ]) ! Allocate memory for the output allocate ( value ( size ( domain ))) ! Evaluate the parsed function do n = 1 , size ( domain ) value ( n ) = evalf ( 1 , [ pi , domain ( n )]) end do end subroutine impure subroutine evaluate_vector_value ( expression , value ) !! This subroutine takes a vector mathematical expression as input, and returns the value. !! !! Usage: !! !!     call evaluate_scalar_value('[0,0,0]',                     output(1:3)) !!     call evaluate_scalar_value('[sin(0.3*pi),0,cos(0,3*pi)]', output(1:3)) !! use :: fparser character ( * ), intent ( in ) :: expression !! Vector-valued mathematical expression real ( wp ), dimension ( 3 ), intent ( out ) :: value !! Result of parsing the expression integer , dimension ( 4 ) :: sep ! Find the vector delimiters sep ( 1 ) = scan ( expression , '[' , back = . false .) sep ( 2 ) = scan ( expression , ',' , back = . false .) sep ( 3 ) = scan ( expression , ',' , back = . true . ) sep ( 4 ) = scan ( expression , ']' , back = . true . ) ! Make sure the expressions are non-empty if ( sep ( 1 ) <= 0 . or . any ( sep ( 2 : 4 ) - sep ( 1 : 3 ) <= 1 )) then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if if ( scan ( expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), '0123456789pi' ) <= 0 . or . & scan ( expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), '0123456789pi' ) <= 0 . or . & scan ( expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), '0123456789pi' ) <= 0 ) then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 3 ) call parsef ( 1 , expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), [ 'pi' ]) call parsef ( 2 , expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), [ 'pi' ]) call parsef ( 3 , expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), [ 'pi' ]) ! Evaluate the parsed function value ( 1 ) = evalf ( 1 , [ pi ]) value ( 2 ) = evalf ( 2 , [ pi ]) value ( 3 ) = evalf ( 3 , [ pi ]) end subroutine impure subroutine evaluate_vector_field ( expression , domain , value ) !! This subroutine takes a vector mathematical function of some variable 'z' as input,  along !! with an array with discrete values for that variable 'z'.  It parses the provided function, !! evaluates it at each 'z'-value in the array, and then returns the discretized scalar field. !! !! Usage: !! !!     call evaluate_scalar_value('[0,0,0]',                     input(1:n), output(1:3,1:n)) !!     call evaluate_scalar_value('[sin(pi*z/2),0,cos(pi*z/2)]', input(1:n), output(1:3,1:n)) !! use :: fparser character ( * ), intent ( in ) :: expression !! Vector-valued function of position 'z' real ( wp ), dimension (:), intent ( in ) :: domain !! Domain of the independent variable 'z' real ( wp ), dimension (:,:), allocatable :: value !! Result of evaluating the field at each point of the domain integer , dimension ( 4 ) :: sep integer :: n ! Allocate memory for the output allocate ( value ( 3 , size ( domain ))) ! Find the vector delimiters sep ( 1 ) = scan ( expression , '[' , back = . false .) sep ( 2 ) = scan ( expression , ',' , back = . false .) sep ( 3 ) = scan ( expression , ',' , back = . true . ) sep ( 4 ) = scan ( expression , ']' , back = . true . ) ! Make sure the expressions are non-empty if ( sep ( 1 ) <= 0 . or . any ( sep ( 2 : 4 ) - sep ( 1 : 3 ) <= 1 )) then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if if ( scan ( expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), '0123456789piz' ) <= 0 . or . & scan ( expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), '0123456789piz' ) <= 0 . or . & scan ( expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), '0123456789piz' ) <= 0 ) then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 3 ) call parsef ( 1 , expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), [ 'pi' , 'z ' ]) call parsef ( 2 , expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), [ 'pi' , 'z ' ]) call parsef ( 3 , expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), [ 'pi' , 'z ' ]) ! Evaluate the parsed function do n = 1 , size ( domain ) value ( 1 , n ) = evalf ( 1 , [ pi , domain ( n )]) value ( 2 , n ) = evalf ( 2 , [ pi , domain ( n )]) value ( 3 , n ) = evalf ( 3 , [ pi , domain ( n )]) end do end subroutine end module","tags":"","loc":"sourcefile/evaluate.f.html","title":"evaluate.f – ​"},{"text":"Contents Modules stdio_m Source Code stdio.f Source Code !> Author:   Jabir Ali Ouassou !> Category: System !> !> This file renames the ISO input/output units to the standard UNIX names, !> defines the ANSI escape codes for colored output, and defines a number of !> auxiliary subroutines for e.g. writing out error and warning messages. module stdio_m use , intrinsic :: iso_fortran_env public ! Declare standard input/output units integer :: stdin = input_unit integer :: stdout = output_unit integer :: stderr = error_unit ! Define escape codes for terminal colors character ( * ), parameter :: color_none = '\u001b[00m' character ( * ), parameter :: color_red = '\u001b[31m' character ( * ), parameter :: color_green = '\u001b[32m' character ( * ), parameter :: color_yellow = '\u001b[33m' character ( * ), parameter :: color_blue = '\u001b[34m' character ( * ), parameter :: color_purple = '\u001b[35m' character ( * ), parameter :: color_cyan = '\u001b[36m' character ( * ), parameter :: color_white = '\u001b[37m' ! Declare public interfaces interface dump !! Public interface for functions that dump results to files module procedure dump_arrays , dump_scalar end interface contains impure subroutine message ( msg ) !! This subroutine provides a way to report a status message. character ( * ), intent ( in ) :: msg write ( stderr , '(a)' ) color_green // ' >> INFO: ' // color_none // msg flush ( stderr ) end subroutine impure subroutine warning ( msg ) !! This subroutine provides a way to report a warning message. character ( * ), intent ( in ) :: msg write ( stderr , '(a)' ) color_yellow // ' >> WARNING: ' // color_none // msg flush ( stderr ) end subroutine impure subroutine error ( msg ) !! This subroutine provides a way to report an error message and halt the program. character ( * ), intent ( in ) :: msg write ( stderr , '(a)' ) color_red // ' >> ERROR: ' // color_none // msg flush ( stderr ) stop end subroutine impure subroutine status_head ( title ) !! This subroutine is used to write boxed status messages to standard out; !! in particular, this routine writes out a boxed title with a timestamp. character ( len =* ), intent ( in ) :: title character ( len = 33 ) :: title_ real :: time integer :: hh , mm , ss ! Calculate the current time call cpu_time ( time ) hh = int ( time / 360 0.0 ) mm = int ( mod ( time , 360 0.0 ) / 6 0.0 ) ss = int ( mod ( time , 6 0.0 )) ! adjust the provided title title_ = '' title_ (( len ( title_ ) - len ( title ) + 1 ) / 2 :) = title ! Write out the boxed header write ( stdout , * ) write ( stdout , '(a)' ) & '╒═══════════════════════════════════╕' write ( stdout , '(a)' ) & '│ ' // title_ // ' │' write ( stdout , '(a)' ) & '├───────────────────────────────────┤' write ( stdout , '(a,3x,a,7x,i3.2,a,i2.2,a,i2.2,3x,a)' ) & '│' , 'Elapsed time:' , hh , ':' , mm , ':' , ss , '│' end subroutine impure subroutine status_body ( title , value ) !! This subroutine is used to write boxed status messages to standard out; !! in particular, this routine writes out the name and value of a variable. character ( len =* ), intent ( in ) :: title character ( len = 20 ) :: title_ class ( * ), intent ( in ) :: value ! Adjust the provided title title_ = trim ( title ) // ':' ! Print out the title and value select type ( value ) type is ( integer ) write ( stdout , '(a,3x,a,i10  ,2x,a)' ) '│' , title_ , value , '│' type is ( real ) write ( stdout , '(a,3x,a,f10.8,2x,a)' ) '│' , title_ , value , '│' type is ( double precision ) write ( stdout , '(a,3x,a,f10.8,2x,a)' ) '│' , title_ , value , '│' end select end subroutine impure subroutine status_foot () !! This subroutine is used to write boxed status messages to standard out; !! in particular, this routine writes out the bottom edge of such a box. ! Write out the boxed footer write ( stdout , '(a)' ) & '╘═══════════════════════════════════╛' ! Flush the information to standard out flush ( unit = stdout ) end subroutine impure subroutine status_box ( title ) !! This subroutine is used to write boxed status messages to standard out. character ( len =* ), intent ( in ) :: title character ( len = 33 ) :: title_ ! adjust the provided title title_ = '' title_ (( len ( title_ ) - len ( title ) + 1 ) / 2 :) = title ! Write out the boxed message write ( stdout , * ) write ( stdout , '(a)' ) & '╒═══════════════════════════════════╕' write ( stdout , '(a)' ) & '│ ' // title_ // ' │' write ( stdout , '(a)' ) & '╘═══════════════════════════════════╛' end subroutine impure function input ( file ) result ( unit ) !! This function is used to open an input file for reading. character ( len =* ), intent ( in ) :: file integer :: iostat integer :: unit ! Open the output file open ( newunit = unit , file = file , iostat = iostat , action = 'read' , status = 'old' ) if ( iostat /= 0 ) then call error ( 'Failed to open input file \"' // file // '\"!' ) end if end function impure function output ( file ) result ( unit ) !! This function is used to open an output file for writing. character ( len =* ), intent ( in ) :: file integer :: iostat integer :: unit ! Open the output file open ( newunit = unit , file = file , iostat = iostat , action = 'write' , status = 'replace' ) if ( iostat /= 0 ) then call error ( 'Failed to open output file \"' // file // '\"!' ) end if end function impure subroutine dump_arrays ( filename , arrays , header ) !! This subroutine is used to dump numerical arrays to an output file. use :: iso_fortran_env character ( len =* ), intent ( in ) :: filename real ( real64 ), dimension (:), intent ( in ) :: arrays character ( len =* ), dimension (:), intent ( in ) :: header real ( real64 ), dimension ( size ( arrays ) / size ( header ), size ( header )) :: matrix integer :: unit integer :: n ! Reshape the data matrix = reshape ( arrays , shape ( matrix )) ! Open the output file unit = output ( filename ) ! Write the header line write ( unit , '(*(a20,:,\"\t\"))' ) '# ' // header ( 1 ), header ( 2 :) ! Loop over the matrix rows do n = 1 , size ( matrix , 1 ) ! Write the matrix column to file write ( unit , '(*(es20.12e3,:,\"\t\"))' ) matrix ( n ,:) end do ! Close the output file close ( unit = unit ) end subroutine impure subroutine dump_scalar ( filename , scalar ) !! This subroutine is used to dump a numerical result to an output file. use :: iso_fortran_env character ( len =* ), intent ( in ) :: filename real ( real64 ), intent ( in ) :: scalar character ( len = 2048 ) :: str integer :: unit integer :: n ! Open the output file unit = output ( filename ) ! Write out command-line arguments do n = 1 , command_argument_count () call get_command_argument ( n , str ) write ( unit , '(a,\"\t\")' , advance = 'no' ) trim ( str ) end do ! Write the scalar value to file write ( unit , '(*(es20.12e3,:,\"\t\"))' ) scalar ! Close the output file close ( unit = unit ) end subroutine end module","tags":"","loc":"sourcefile/stdio.f.html","title":"stdio.f – ​"},{"text":"Contents Modules condmat_m Source Code condmat.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file provides a common interface to a library of mathematical objects !> that can be useful for modelling materials in condensed matter physics. module condmat_m use :: math_m use :: spin_m use :: nambu_m use :: propagator_m end module","tags":"","loc":"sourcefile/condmat.f.html","title":"condmat.f – ​"},{"text":"Contents Modules basic_m Source Code basic.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file defines a module containing the machine size of single-precision, double-precision, and quadruple-precision !> floating point numbers; to declare the floating point precision of a variable, use real(sp), real(dp), or real(qp) as !> the type of the variable. It also defines the working-precision, which will be the default kind for module procedures. !> As for module procedures, this library defines some common utility functions for working with e.g. complex numbers. module basic_m use :: iso_fortran_env ! Declare floating-point precisions integer , parameter :: sp = real32 !! Single precision integer , parameter :: dp = real64 !! Double precision integer , parameter :: qp = real128 !! Quadruple precision integer , parameter :: wp = dp !! Working precision ! Define common mathematical constants real ( wp ), parameter :: inf = huge ( 1.0_wp ) !! Numerical infinity real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! Numerical infinitesimal real ( wp ), parameter :: pi = atan ( 1.0_wp ) * 4.0_wp !! Circle constant contains pure elemental function re ( z ) result ( x ) !! Returns the real part of a complex number z=x+iy. !! !! @NOTE: !!   This function might be replaced by the structure !!   notation z%re when common compilers support it. complex ( wp ), intent ( in ) :: z !! Complex number real ( wp ) :: x !! Real part x = real ( z , kind = wp ) end function pure elemental function im ( z ) result ( y ) !! Returns the imaginary part of a complex number z=x+iy. !! !! @NOTE: !!   This function might be replaced by the structure !!   notation z%im when common compilers support it. complex ( wp ), intent ( in ) :: z !! Complex number real ( wp ) :: y !! Imaginary part y = aimag ( z ) end function pure elemental function cx ( x , y ) result ( z ) !! Returns the complex number z=x+iy. real ( wp ), intent ( in ) :: x !! Real part real ( wp ), intent ( in ), optional :: y !! Imaginary part complex ( wp ) :: z !! Complex number if ( present ( y )) then z = cmplx ( x , y , kind = wp ) else z = cmplx ( x , 0 , kind = wp ) end if end function pure elemental function arg ( z ) result ( t ) !! Returns the complex argument θ of a complex number z=r·exp(iθ). complex ( wp ), intent ( in ) :: z !! Complex number real ( wp ) :: t !! Complex argument t = atan2 ( im ( z ), re ( z )) end function pure function unitvector ( v ) result ( r ) !! If the argument has a finite norm, then it will be rescaled to a unit !! vector. If that norm is zero, then a zero vector is returned instead. real ( wp ), dimension ( 3 ), intent ( in ) :: v !! Vector real ( wp ), dimension ( 3 ) :: r !! Unit vector r = v / ( norm2 ( v ) + eps ) end function pure function nonzero ( v ) result ( r ) !! Checks whether or not the argument has a finite norm. real ( wp ), dimension (:), intent ( in ) :: v !! Vector logical :: r !! Finite r = norm2 ( v ) > eps end function end module","tags":"","loc":"sourcefile/basic.f.html","title":"basic.f – ​"},{"text":"Contents Modules calculus_m Source Code calculus.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file defines functions that perform some common calculus operations. module calculus_m use :: basic_m contains !-------------------------------------------------------------------------------- ! Specific implementations of the `mean` interface !-------------------------------------------------------------------------------- pure function mean_array_re ( x ) result ( r ) !! Calculates the mean value of a real-valued array. real ( wp ), dimension (:), intent ( in ) :: x !! Real-valued array real ( wp ) :: r !! Mean value <x> r = sum ( x ) / max ( 1 , size ( x )) end function pure function mean_array_cx ( x ) result ( r ) !! Calculates the mean value of a complex-valued array. complex ( wp ), dimension (:), intent ( in ) :: x !! Complex-valued array complex ( wp ) :: r !! Mean value <x> r = sum ( x ) / max ( 1 , size ( x )) end function !-------------------------------------------------------------------------------- ! Specific implementations of the `differentiate` interface !-------------------------------------------------------------------------------- pure function differentiate_array_re ( x , y ) result ( r ) !! This function calculates the numerical derivative of an array y with respect to x, using a central difference approximation !! at the interior points and forward/backward difference approximations at the exterior points. Note that since all the three !! approaches yield two-point approximations of the derivative, the mesh spacing of x does not necessarily have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), dimension ( size ( x )) :: r !! Derivative dy/dx ! Differentiate using finite differences associate ( n => size ( x )) r ( 1 ) = ( y ( 1 + 1 ) - y ( 1 )) / ( x ( 1 + 1 ) - x ( 1 )) r ( 1 + 1 : n - 1 ) = ( y ( 1 + 2 : n ) - y ( 1 : n - 2 )) / ( x ( 1 + 2 : n ) - x ( 1 : n - 2 )) r ( n ) = ( y ( n ) - y ( n - 1 )) / ( x ( n ) - x ( n - 1 )) end associate end function pure function differentiate_array_cx ( x , y ) result ( r ) !! Complex version of differentiate_array_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) complex ( wp ), dimension ( size ( x )) :: r !! Derivative dy/dx ! Differentiate using finite differences associate ( n => size ( x )) r ( 1 ) = ( y ( 1 + 1 ) - y ( 1 )) / ( x ( 1 + 1 ) - x ( 1 )) r ( 1 + 1 : n - 1 ) = ( y ( 1 + 2 : n ) - y ( 1 : n - 2 )) / ( x ( 1 + 2 : n ) - x ( 1 : n - 2 )) r ( n ) = ( y ( n ) - y ( n - 1 )) / ( x ( n ) - x ( n - 1 )) end associate end function !-------------------------------------------------------------------------------- ! Specific implementations of the `integrate` interface !-------------------------------------------------------------------------------- pure function integrate_array_re ( x , y ) result ( r ) !! This function calculates the integral of an array y with respect to x using a trapezoid !! approximation. Note that the mesh spacing of x does not necessarily have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ) :: r !! Integral ∫y(x)·dx ! Integrate using the trapezoidal rule associate ( n => size ( x )) r = sum (( y ( 1 + 1 : n - 0 ) + y ( 1 + 0 : n - 1 )) * ( x ( 1 + 1 : n - 0 ) - x ( 1 + 0 : n - 1 ))) / 2 end associate end function pure function integrate_array_cx ( x , y ) result ( r ) !! Complex version of integrate_array_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) complex ( wp ) :: r !! Integral ∫y(x)·dx ! Integrate using the trapezoidal rule associate ( n => size ( x )) r = sum (( y ( 1 + 1 : n - 0 ) + y ( 1 + 0 : n - 1 )) * ( x ( 1 + 1 : n - 0 ) - x ( 1 + 0 : n - 1 ))) / 2 end associate end function function integrate_range_re ( x , y , a , b ) result ( r ) !! This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on !! discrete numerical data, and subsequently evaluates the integral of the interpolation in the !! range (a,b). Note that the mesh spacing of x does not necessarily have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: a !! Left endpoint real ( wp ), intent ( in ) :: b !! Right endpoint real ( wp ) :: r !! Integral ∫y(x)·dx external :: dpchez real ( wp ), external :: dpchqa real ( wp ), dimension ( size ( x )) :: d integer :: err ! Create a PCHIP interpolation of the input data call dpchez ( size ( x ), x , y , d , . false ., 0 , 0 , err ) ! Integrate the interpolation in the provided range r = dpchqa ( size ( x ), x , y , d , a , b , err ) end function function integrate_range_cx ( x , y , a , b ) result ( r ) !! Complex version of integrate_range_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: a !! Left endpoint real ( wp ), intent ( in ) :: b !! Right endpoint complex ( wp ) :: r !! Integral ∫y(x)·dx ! Integrate the real and imaginary parts separately r = cx ( integrate_range_re ( x , re ( y ), a , b ),& integrate_range_re ( x , im ( y ), a , b ) ) end function !-------------------------------------------------------------------------------- ! Specific implementations of the `interpolate` interface !-------------------------------------------------------------------------------- function interpolate_array_re ( x , y , p ) result ( r ) !! This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on discrete numerical data, !! and evaluates the interpolation at points p. Note that the mesh spacing of x does not necessarily have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), dimension (:), intent ( in ) :: p !! Interpolation domain p real ( wp ), dimension ( size ( p )) :: r !! Interpolation result y(p) external :: dpchez external :: dpchfe real ( wp ), dimension ( size ( x )) :: d integer :: err ! Create a PCHIP interpolation of the input data call dpchez ( size ( x ), x , y , d , . false ., 0 , 0 , err ) ! Extract the interpolated data at provided points call dpchfe ( size ( x ), x , y , d , 1 , . false ., size ( p ), p , r , err ) end function function interpolate_array_cx ( x , y , p ) result ( r ) !! Complex version of interpolate_array_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), dimension (:), intent ( in ) :: p !! Interpolation domain p complex ( wp ), dimension ( size ( p )) :: r !! Interpolation result y(p) ! Interpolate the real and imaginary parts separately r = cx ( interpolate_array_re ( x , re ( y ), p ),& interpolate_array_re ( x , im ( y ), p ) ) end function function interpolate_point_re ( x , y , p ) result ( r ) !! Wrapper for interpolate_array_re that accepts scalar arguments. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: p !! Interpolation point p real ( wp ) :: r !! Interpolation result y(p) real ( wp ), dimension ( 1 ) :: rs ! Perform the interpolation rs = interpolate_array_re ( x , y , [ p ]) ! Extract the scalar result r = rs ( 1 ) end function function interpolate_point_cx ( x , y , p ) result ( r ) !! Complex version of interpolate_point_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: p !! Interpolation point p complex ( wp ) :: r !! Interpolation result y(p) complex ( wp ), dimension ( 1 ) :: rs ! Perform the interpolation rs = cx ( interpolate_array_re ( x , re ( y ), [ p ]),& interpolate_array_re ( x , im ( y ), [ p ]) ) ! Extract the scalar result r = rs ( 1 ) end function pure function interpolate_point_matrix_re ( x , y , p ) result ( r ) !! Perform a Piecewise Cubic Hermitian Interpolation of a matrix function using Catmull-Rom splines. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension (:,:,:), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: p !! Interpolation point p real ( wp ), dimension ( size ( y , 1 ), size ( y , 2 )) :: r !! Interpolation result y(p) integer :: n , m real ( wp ) :: t ! Find the nearest known point y(x) m = size ( x ) n = floor ( p * ( m - 1 ) + 1 ); ! Perform the interpolation if ( n <= 0 ) then ! Exterior: nearest extrapolation r = y (:,:, 1 ) else if ( n >= m ) then ! Exterior: nearest extrapolation r = y (:,:, m ) else ! Interior: spline interpolation t = ( p - x ( max ( n , 1 ))) / ( x ( min ( n + 1 , m )) - x ( max ( n , 1 ))) r = y (:,:, max ( n - 1 , 1 )) * ( - 0.5 * t + 1.0 * t ** 2 - 0.5 * t ** 3 ) & + y (:,:, max ( n - 0 , 1 )) * ( + 1.0 - 2.5 * t ** 2 + 1.5 * t ** 3 ) & + y (:,:, min ( n + 1 , m )) * ( + 0.5 * t + 2.0 * t ** 2 - 1.5 * t ** 3 ) & + y (:,:, min ( n + 2 , m )) * ( - 0.5 * t ** 2 + 0.5 * t ** 3 ) end if end function !-------------------------------------------------------------------------------- ! Specific implementations of the `linspace` interface !-------------------------------------------------------------------------------- pure subroutine linspace_array_re ( array , first , last ) !! Populates an existing array with elements from `first` to `last`, inclusive. real ( wp ), dimension (:), intent ( out ) :: array !! Output array to populate real ( wp ), intent ( in ) :: first !! Value of first element real ( wp ), intent ( in ) :: last !! Value of last  element integer :: n do n = 1 , size ( array ) array ( n ) = first + (( last - first ) * ( n - 1 )) / ( size ( array ) - 1 ) end do end subroutine end module","tags":"","loc":"sourcefile/calculus.f.html","title":"calculus.f – ​"},{"text":"Contents Modules propagator_m Source Code propagator.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module defines the data type 'propagator', which represents the propagator at a given position and energy. !> The equilibrium propagators (retarded and advanced) are stored internally using the Riccati parameters γ and γ~ !> and their derivatives, while the nonequilibrium propagator (Keldysh) is represented by taking the traces of the !> distribution function and its derivatives. These quantities are together sufficient to reconstruct the full 8×8 !> propagator and its derivatives, and can be used to calculate associated physical quantities such as the density !> of states, charge currents, spin currents, heat currents, spin-heat currents, and various accumulation effects. module propagator_m use :: math_m use :: spin_m use :: nambu_m private ! Public interface public propagator ! Type declaration type propagator ! Riccati parametrization of equilibrium propagators (retarded and advanced) type ( spin ) :: g !! Riccati parameter γ type ( spin ) :: gt !! Riccati parameter γ~ type ( spin ) :: dg !! Riccati parameter ∇γ type ( spin ) :: dgt !! Riccati parameter ∇γ~ type ( spin ) :: d2g !! Riccati parameter ∇²γ type ( spin ) :: d2gt !! Riccati parameter ∇²γ~ type ( spin ) :: N !! Riccati normalization N type ( spin ) :: Nt !! Riccati normalization N~ ! Distribution-trace parametrization of nonequilibrium propagators (Keldysh) real ( wp ), dimension ( 0 : 7 ) :: h = [ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] !! Distribution-trace H real ( wp ), dimension ( 0 : 7 ) :: dh = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] !! Distribution-trace ∇H real ( wp ), dimension ( 0 : 7 ) :: d2h = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] !! Distribution-trace ∇²H contains ! Accessors for the propagator matrices represented by this object procedure :: retarded => propagator_retarded !! Retarded propagator G&#94;R procedure :: retarded_gradient => propagator_retarded_gradient !! Retarded propagator ∇G&#94;R procedure :: retarded_laplacian => propagator_retarded_laplacian !! Retarded propagator ∇²G&#94;R procedure :: advanced => propagator_advanced !! Advanced propagator G&#94;A procedure :: advanced_gradient => propagator_advanced_gradient !! Advanced propagator ∇G&#94;A procedure :: advanced_laplacian => propagator_advanced_laplacian !! Advanced propagator ∇²G&#94;A procedure :: keldysh => propagator_keldysh !! Keldysh propagator G&#94;K procedure :: keldysh_gradient => propagator_keldysh_gradient !! Keldysh propagator ∇G&#94;K ! procedure  :: keldysh_laplacian       => propagator_keldysh_laplacian       !! Keldysh propagator ∇²G&#94;K procedure :: distribution => propagator_distribution !! Distribution matrix H procedure :: distribution_gradient => propagator_distribution_gradient !! Distribution matrix ∇H ! procedure  :: distribution_laplacian  => propagator_distribution_laplacian  !! Distribution matrix ∇²H ! Accessors for derived matrices used to solve the kinetic equations procedure :: dissipation => propagator_dissipation !! Dissipation matrix M procedure :: dissipation_gradient => propagator_dissipation_gradient !! Dissipation matrix ∇M procedure :: condensate => propagator_condensate !! Condensate matrix Q procedure :: condensate_gradient => propagator_condensate_gradient !! Condensate matrix ∇Q procedure :: selfenergy1 => propagator_selfenergy1 !! Selfenergy matrix R₁ procedure :: selfenergy2 => propagator_selfenergy2 !! Selfenergy matrix R₂ ! Accessors for physical quantities that derive from the propagators procedure :: supercurrent => propagator_supercurrent !! Spectral supercurrents procedure :: lossycurrent => propagator_lossycurrent !! Spectral dissipative currents procedure :: accumulation => propagator_accumulation !! Spectral accumulations procedure :: correlation => propagator_correlation !! Spectral correlations procedure :: density => propagator_density !! Spin-resolved density of states ! Miscellaneous utiliy functions for working with propagator objects procedure :: save => propagator_save !! Export Riccati parameters procedure :: load => propagator_load !! Import Riccati parameters end type ! Type constructor interface propagator module procedure propagator_construct_vacuum , propagator_construct_riccati , propagator_construct_bcs end interface contains pure function propagator_construct_vacuum () result ( this ) !! Construct a vacuum propagator, i.e. a propagator which satisfies G=0. type ( propagator ) :: this !! Constructed object continue end function pure function propagator_construct_riccati ( g , gt , dg , dgt ) result ( this ) !! Construct an arbitrary state by explicitly providing the Riccati parameters. !! Unspecified Riccati parameters default to zero due to the spin constructors. !! The distribution function defaults to equilibrium at zero temperature. type ( propagator ) :: this !! Constructed object type ( spin ), intent ( in ) :: g !! Riccati parameter γ type ( spin ), intent ( in ) :: gt !! Riccati parameter γ~ type ( spin ), optional , intent ( in ) :: dg !! Riccati parameter ∇γ type ( spin ), optional , intent ( in ) :: dgt !! Riccati parameter ∇γ~ ! Copy Riccati parameters into the new object this % g = g this % gt = gt ! Copy Riccati derivatives into the new object if ( present ( dg )) this % dg = dg if ( present ( dgt )) this % dgt = dgt ! Update the normalization matrices associate ( g => this % g , gt => this % gt , N => this % N , Nt => this % Nt ) this % N = inverse ( pauli0 - g * gt ) this % Nt = inverse ( pauli0 - gt * g ) end associate end function pure function propagator_construct_bcs ( energy , gap ) result ( this ) !! Constructs a state corresponding to a BCS superconductor at some given energy, !! which may have an imaginary term representing inelastic scattering. The second !! argument 'gap' is used to provide the superconducting order parameter Δ. !! The distribution function defaults to equilibrium at zero temperature. type ( propagator ) :: this !! Constructed object complex ( wp ), intent ( in ) :: energy !! Quasiparticle energy (including inelastic scattering contribution) complex ( wp ), intent ( in ) :: gap !! Superconducting order parameter (including superconducting phase) real ( wp ) :: p complex ( wp ) :: t , u complex ( wp ) :: a , b ! Calculate the superconducting gap and phase u = abs ( gap ) / energy p = arg ( gap ) ! Calculate the θ-parameter t = ( log ( 1 + u ) - log ( 1 - u )) / 2 ! Calculate the scalar Riccati parameters a and b a = ( exp ( + t ) - exp ( - t )) / ( 2 + exp ( + t ) + exp ( - t )) * exp ( ( 0 , + 1 ) * p ) b = - ( exp ( + t ) - exp ( - t )) / ( 2 + exp ( + t ) + exp ( - t )) * exp ( ( 0 , - 1 ) * p ) ! Calculate the matrix Riccati parameters γ and γ~ this % g = a * (( 0.0_wp , 1.0_wp ) * pauli2 ) this % gt = b * (( 0.0_wp , 1.0_wp ) * pauli2 ) ! Update the normalization matrices this % N = inverse ( pauli0 - this % g * this % gt ) this % Nt = inverse ( pauli0 - this % gt * this % g ) end function pure function propagator_retarded ( this ) result ( GR ) !! Calculates the 4×4 retarded propagator G&#94;R. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: GR !! Retarded propagator ! Construct the propagator from the Riccati parameters associate ( g => this % g , gt => this % gt , & N => this % N , Nt => this % Nt , & I => pauli0 , M => GR % matrix ) M ( 1 : 2 , 1 : 2 ) = ( + 1.0_wp ) * N * ( I + g * gt ) M ( 1 : 2 , 3 : 4 ) = ( + 2.0_wp ) * N * g M ( 3 : 4 , 1 : 2 ) = ( - 2.0_wp ) * Nt * gt M ( 3 : 4 , 3 : 4 ) = ( - 1.0_wp ) * Nt * ( I + gt * g ) end associate end function pure function propagator_retarded_gradient ( this , gauge ) result ( dGR ) !! Calculates the 4×4 retarded propagator gradient ∇G&#94;R. If an optional !! gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dGR !! Retarded propagator gradient ! Construct the propagator from the Riccati parameters associate ( g => this % g , gt => this % gt , & dg => this % dg , dgt => this % dgt , & N => this % N , Nt => this % Nt , & I => pauli0 , M => dGR % matrix ) M ( 1 : 2 , 1 : 2 ) = ( + 2.0_wp ) * N * ( dg * gt + g * dgt ) * N M ( 1 : 2 , 3 : 4 ) = ( + 2.0_wp ) * N * ( dg + g * dgt * g ) * Nt M ( 3 : 4 , 1 : 2 ) = ( - 2.0_wp ) * Nt * ( dgt + gt * dg * gt ) * N M ( 3 : 4 , 3 : 4 ) = ( - 2.0_wp ) * Nt * ( dgt * g + gt * dg ) * Nt end associate ! Construct the gauge-covariant terms if ( present ( gauge )) then associate ( A => gauge , GR => this % retarded (), i => ( 0.0_wp , 1.0_wp )) dGR = dGR - i * ( A * GR - GR * A ) end associate end if end function pure function propagator_retarded_laplacian ( this ) result ( d2GR ) !! Calculates the 4×4 retarded propagator gradient ∇²G&#94;R. !! !! @TODO: !!   Implement support for gauge-covariant laplacians. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: d2GR !! Retarded propagator laplacian type ( spin ) :: D , Dt , dD , dDt , F , Ft , dF , dFt ! Construct the propagator from the Riccati parameters associate ( g => this % g , gt => this % gt , & dg => this % dg , dgt => this % dgt , & d2g => this % d2g , d2gt => this % d2gt , & N => this % N , Nt => this % Nt , & I => pauli0 , M => d2GR % matrix ) ! Calculate 1st-derivative auxiliary matrices D = dg * gt + g * dgt Dt = dgt * g + gt * dg F = dg + g * dgt * g Ft = dgt + gt * dg * gt ! Calculate 2nd-derivative auxiliary matrices dD = d2g * gt + g * d2gt + 2.0_wp * dg * dgt dDt = d2gt * g + gt * d2g + 2.0_wp * dgt * dg dF = d2g + g * d2gt * g + dg * dgt * g + g * dgt * dg dFt = d2gt + gt * d2g * gt + dgt * dg * gt + gt * dg * dgt ! Calculate the propagator matrix M ( 1 : 2 , 1 : 2 ) = ( + 2.0_wp ) * N * ( dD + 2.0_wp * D * N * D ) * N M ( 1 : 2 , 3 : 4 ) = ( + 2.0_wp ) * N * ( dF + D * N * F + F * Nt * Dt ) * Nt M ( 3 : 4 , 1 : 2 ) = ( - 2.0_wp ) * Nt * ( dFt + Dt * Nt * Ft + Ft * N * D ) * N M ( 3 : 4 , 3 : 4 ) = ( - 2.0_wp ) * Nt * ( dDt + 2.0_wp * Dt * Nt * Dt ) * Nt end associate end function pure function propagator_advanced ( this ) result ( GA ) !! Calculates the 4×4 advanced propagator G&#94;A. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: GA !! Advanced propagator type ( nambu ) :: GR !! Retarded propagator ! Calculate the retarded propagator GR = this % retarded () ! Use the identity GA = -τ₃GR†τ₃ GA = nambuv ( 4 ) * transpose ( conjg ( - GR % matrix )) * nambuv ( 4 ) end function pure function propagator_advanced_gradient ( this , gauge ) result ( dGA ) !! Calculates the 4×4 advanced propagator gradient ∇G&#94;A. If an optional !! gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dGA !! Advanced propagator gradient type ( nambu ) :: dGR !! Retarded propagator gradient ! Calculate the retarded propagator gradient dGR = this % retarded_gradient ( gauge ) ! Use the identity GA = -τ₃GR†τ₃ dGA = nambuv ( 4 ) * transpose ( conjg ( - dGR % matrix )) * nambuv ( 4 ) end function pure function propagator_advanced_laplacian ( this ) result ( d2GA ) !! Calculates the 4×4 retarded propagator gradient ∇²G&#94;A. !! !! @TODO: !!   Implement support for gauge-covariant laplacians. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: d2GA !! Advanced propagator laplacian type ( nambu ) :: d2GR !! Retarded propagator laplacian ! Calculate the retarded propagator laplacian d2GR = this % retarded_laplacian () ! Use the identity GA = -τ₃GR†τ₃ d2GA = nambuv ( 4 ) * transpose ( conjg ( - d2GR % matrix )) * nambuv ( 4 ) end function pure function propagator_keldysh ( this ) result ( GK ) !! Calculates the 4×4 Keldysh propagator G&#94;K. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: GK !! Propagator matrix type ( nambu ) :: GR , GA , H ! Calculate equilibrium propagators and the distribution GR = this % retarded () GA = this % advanced () H = this % distribution () ! Use this to calculate the nonequilibrium propagator GK = GR * H - H * GA end function pure function propagator_keldysh_gradient ( this , gauge ) result ( dGK ) !! Calculates the 4×4 Keldysh propagator gradient ∇G&#94;K. If an optional !! gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dGK !! Propagator gradient type ( nambu ) :: GR , GA , H type ( nambu ) :: dGR , dGA , dH ! Calculate equilibrium propagators and the distribution GR = this % retarded () GA = this % advanced () H = this % distribution () ! Calculate the gradients of the matrix functions above dGR = this % retarded_gradient ( gauge ) dGA = this % advanced_gradient ( gauge ) dH = this % distribution_gradient ( gauge ) ! Use this to calculate the nonequilibrium propagator gradient dGK = ( dGR * H - H * dGA ) + ( GR * dH - dH * GA ) end function pure function propagator_distribution ( this ) result ( H ) !! Calculates the 4×4 distribution function matrix H. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: H !! Distribution matrix integer :: i ! Construct the distribution matrix from its Pauli-decomposition do i = 0 , 7 H = H + nambuv ( i ) * this % h ( i ) end do end function pure function propagator_distribution_gradient ( this , gauge ) result ( dH ) !! Calculates the 4×4 distribution function gradient ∇H. If an optional !! gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dH !! Distribution gradient integer :: i ! Construct the distribution matrix from its Pauli-decomposition do i = 0 , 7 dH = dH + nambuv ( i ) * this % dh ( i ) end do ! Construct the gauge-covariant terms if ( present ( gauge )) then associate ( A => gauge , H => this % distribution (), i => ( 0.0_wp , 1.0_wp )) dH = dH - i * ( A * H - H * A ) end associate end if end function pure function propagator_supercurrent ( this , gauge ) result ( J ) !! Calculates the spectral supercurrents in the junction. The result is returned in the !! form of an 8-vector containing the charge, spin, heat, and spin-heat currents. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field real ( wp ), dimension ( 0 : 7 ) :: J !! Spectral supercurrent type ( nambu ) :: I !! Matrix supercurrent type ( nambu ) :: H !! Distribution function type ( nambu ) :: GR , dGR !! Retarded propagator type ( nambu ) :: GA , dGA !! Advanced propagator integer :: n ! Calculate the propagators H = this % distribution () GR = this % retarded () GA = this % advanced () dGR = this % retarded_gradient ( gauge ) dGA = this % advanced_gradient ( gauge ) ! Calculate the matrix current I = ( GR * dGR ) * H - H * ( GA * dGA ) ! Pauli-decompose the current do n = 0 , 7 J ( n ) = re ( trace (( nambuv ( 4 ) * nambuv ( n )) * I )) / 8 end do end function pure function propagator_lossycurrent ( this , gauge ) result ( J ) !! Calculates the spectral dissipative currents in the junction. The result is returned in !! the form of an 8-vector containing the charge, spin, heat, and spin-heat currents. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field real ( wp ), dimension ( 0 : 7 ) :: J !! Spectral dissipative current type ( nambu ) :: I !! Matrix dissipative current type ( nambu ) :: dH !! Distribution function type ( nambu ) :: GR !! Retarded propagator type ( nambu ) :: GA !! Advanced propagator integer :: n ! Calculate the propagators dH = this % distribution_gradient ( gauge ) GR = this % retarded () GA = this % advanced () ! Calculate the matrix current I = dH - GR * dH * GA ! Pauli-decompose the current do n = 0 , 7 J ( n ) = re ( trace (( nambuv ( 4 ) * nambuv ( n )) * I )) / 8 end do end function pure function propagator_accumulation ( this ) result ( Q ) !! Calculates the spectral accumulations in the junction. The result is returned in the !! form of an 8-vector containing the charge, spin, heat, and spin-heat accumulations. class ( propagator ), intent ( in ) :: this !! Propagator object real ( wp ), dimension ( 0 : 7 ) :: Q !! Spectral accumulation type ( nambu ) :: GK !! Keldysh propagator integer :: n ! Calculate the propagator GK = this % keldysh () ! Pauli-decompose it do n = 0 , 7 Q ( n ) = - re ( trace ( nambuv ( n ) * GK )) / 8 end do end function pure function propagator_correlation ( this ) result ( r ) !! Calculates the spectral pair-correlation function. This is useful e.g. for !! self-consistently calculating the superconducting gap in a superconductor. class ( propagator ), intent ( in ) :: this !! Propagator object complex ( wp ) :: r !! Spectral correlation type ( nambu ) :: GK !! Keldysh propagator type ( spin ) :: f , ft !! Anomalous propagators ! Calculate the propagator GK = this % keldysh () ! Extract the anomalous components f = GK % matrix ( 1 : 2 , 3 : 4 ) ft = GK % matrix ( 3 : 4 , 1 : 2 ) ! Trace out the singlet component r = trace (( 0.0_wp , - 1.0_wp ) * pauli2 * ( f + conjg ( ft ))) / 8 end function pure function propagator_density ( this ) result ( D ) !! Calculates the spin-resolved local density of states. class ( propagator ), intent ( in ) :: this real ( wp ), dimension ( 0 : 7 ) :: D type ( nambu ) :: GR type ( spin ) :: g , gt ! Extract the normal retarded propagator GR = this % retarded () g = + GR % matrix ( 1 : 2 , 1 : 2 ) gt = - GR % matrix ( 3 : 4 , 3 : 4 ) ! Calculate the spin-resolved density of states, ! for both positive and negative energy values D ( 0 : 3 ) = re ( trace ( pauli * g )) / 2 D ( 4 : 7 ) = re ( trace ( pauli * gt )) / 2 end function pure elemental subroutine propagator_save ( this , other ) !! Defines a function for exporting Riccati parameters. class ( propagator ), intent ( inout ) :: this class ( propagator ), intent ( inout ) :: other ! Copy all the Riccati parameters other % g = this % g other % gt = this % gt other % dg = this % dg other % dgt = this % dgt other % d2g = this % d2g other % d2gt = this % d2gt other % N = this % N other % Nt = this % Nt end subroutine pure elemental subroutine propagator_load ( this , other ) !! Defines a function for importing Riccati parameters. class ( propagator ), intent ( inout ) :: this class ( propagator ), intent ( inout ) :: other ! Copy all the Riccati parameters this % g = other % g this % gt = other % gt this % dg = other % dg this % dgt = other % dgt this % d2g = other % d2g this % d2gt = other % d2gt this % N = other % N this % Nt = other % Nt end subroutine pure function propagator_dissipation ( this ) result ( M ) !! Calculate the dissipation matrix M = ∂J/∂H', where J is the !! current and H' is the gradient of the distribution function. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: M type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the dissipation matrix do i = 0 , 7 do j = 0 , 7 M ( i , j ) = trace ( N ( i ) * N ( j ) - N ( i ) * GR * N ( j ) * GA ) / 4 end do end do end function pure function propagator_dissipation_gradient ( this ) result ( dM ) !! Calculate the gradient of the dissipation matrix M'. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: dM type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA , dGR , dGA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the propagator gradients dGR = this % retarded_gradient () dGA = this % advanced_gradient () ! Construct the dissipation matrix do j = 0 , 7 do i = 0 , 7 dM ( i , j ) = - trace ( N ( i ) * dGR * N ( j ) * GA + N ( i ) * GR * N ( j ) * dGA ) / 4 end do end do end function pure function propagator_condensate ( this ) result ( Q ) !! Calculate the condensate matrix Q = ∂J/∂H, where J is the !! current and H is the nonequilibrium distribution function. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: Q type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA , dGR , dGA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the propagator gradients dGR = this % retarded_gradient () dGA = this % advanced_gradient () ! Construct the condensate matrix do j = 0 , 7 do i = 0 , 7 Q ( i , j ) = trace ( N ( j ) * N ( i ) * GR * dGR - N ( i ) * N ( j ) * GA * dGA ) / 4 end do end do end function pure function propagator_condensate_gradient ( this ) result ( dQ ) !! Calculate the gradient of the condensate matrix Q'. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: dQ type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA , dGR , dGA , d2GR , d2GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the propagator gradients dGR = this % retarded_gradient () dGA = this % advanced_gradient () ! Construct the propagator laplacians d2GR = this % retarded_laplacian () d2GA = this % advanced_laplacian () ! Construct the condensate matrix do j = 0 , 7 do i = 0 , 7 dQ ( i , j ) = trace ( N ( j ) * N ( i ) * ( dGR * dGR + GR * d2GR ) - N ( i ) * N ( j ) * ( dGA * dGA + GA * d2GA ) ) / 4 end do end do end function pure function propagator_selfenergy1 ( this , S ) result ( R ) !! Calculate the 1st-order self-energy contribution to the kinetic equations. class ( propagator ), intent ( in ) :: this type ( nambu ), intent ( in ) :: S complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: R type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the self-energy matrix do j = 0 , 7 do i = 0 , 7 R ( i , j ) = ( 0.00 , 0.25 ) * trace ( ( N ( i ) * S - S * N ( i )) * ( GR * N ( j ) - N ( j ) * GA ) ) end do end do end function pure function propagator_selfenergy2 ( this , S ) result ( R ) !! Calculate the 2nd-order self-energy contribution to the kinetic equations. class ( propagator ), intent ( in ) :: this type ( nambu ), intent ( in ) :: S complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: R type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the self-energy matrix do j = 0 , 7 do i = 0 , 7 R ( i , j ) = ( 0.00 , 0.25 ) * trace ( ( N ( i ) * S - S * N ( i )) * ( GR * S * GR * N ( j ) - N ( j ) * GA * S * GA + GR * ( N ( j ) * S - S * N ( j )) * GA ) ) end do end do end function end module","tags":"","loc":"sourcefile/propagator.f.html","title":"propagator.f – ​"},{"text":"Contents Modules nambu_m Source Code nambu.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module defines the data type 'nambu', which represents 4×4 complex matrices in spin and Nambu space. The module !> overloads arithmetic operators to work with the new type, and defines and exports the Pauli matrices as constants. module nambu_m use :: math_m use :: spin_m private ! Public interface public nambu , nambuv public inverse , trace , conjg , sum ! Type declaration type nambu complex ( wp ) :: matrix ( 4 , 4 ) = 0.0_wp !! Encapsulate a spin and Nambu space matrix contains ! Overload constructors and operators generic :: nambu => cons_rscalar , cons_cscalar , cons_cmatrix , cons_nambu generic :: assignment ( = ) => assr_rscalar , assr_cscalar , assr_cmatrix , assl_cmatrix generic :: operator ( + ) => addl_rscalar , addr_rscalar , addl_cscalar , addr_cscalar , addl_cmatrix , addr_cmatrix , add_nambu generic :: operator ( - ) => subl_rscalar , subr_rscalar , subl_cscalar , subr_cscalar , subl_cmatrix , subr_cmatrix , sub_nambu generic :: operator ( * ) => mull_rscalar , mulr_rscalar , mull_cscalar , mulr_cscalar , mull_cmatrix , mulr_cmatrix , mul_nambu generic :: operator ( / ) => divr_rscalar , divr_cscalar generic :: operator ( ** ) => expr_iscalar ! Specific methods for construction procedure , nopass , private :: cons_nambu => nambu_cons_nambu !! Construction from a nambu object procedure , nopass , private :: cons_rscalar => nambu_cons_rscalar !! Construction from a real scalar procedure , nopass , private :: cons_cscalar => nambu_cons_cscalar !! Construction from a complex scalar procedure , nopass , private :: cons_cmatrix => nambu_cons_cmatrix !! Construction from a complex matrix ! Specific implementations of assignments procedure , pass ( this ), private :: assr_rscalar => nambu_assr_rscalar !! Assign data from a real scalar      (right) procedure , pass ( this ), private :: assr_cscalar => nambu_assr_cscalar !! Assign data from a complex scalar   (right) procedure , pass ( this ), private :: assl_cmatrix => nambu_assl_cmatrix !! Assign data into a complex matrix   (left) procedure , pass ( this ), private :: assr_cmatrix => nambu_assr_cmatrix !! Assign data from a complex matrix   (right) ! Specific implementations of addition procedure , pass ( this ), private :: add_nambu => nambu_add_nambu !! Addition with a nambu object procedure , pass ( this ), private :: addl_rscalar => nambu_addl_rscalar !! Addition with a real scalar         (left) procedure , pass ( this ), private :: addr_rscalar => nambu_addr_rscalar !! Addition with a real scalar         (right) procedure , pass ( this ), private :: addl_cscalar => nambu_addl_cscalar !! Addition with a complex scalar      (left) procedure , pass ( this ), private :: addr_cscalar => nambu_addr_cscalar !! Addition with a complex scalar      (right) procedure , pass ( this ), private :: addl_cmatrix => nambu_addl_cmatrix !! Addition with a complex matrix      (left) procedure , pass ( this ), private :: addr_cmatrix => nambu_addr_cmatrix !! Addition with a complex matrix      (right) ! Specific implementations of subtraction procedure , pass ( this ), private :: sub_nambu => nambu_sub_nambu !! Subtraction with a nambu object procedure , pass ( this ), private :: subl_rscalar => nambu_subl_rscalar !! Subtraction with a real scalar      (left) procedure , pass ( this ), private :: subr_rscalar => nambu_subr_rscalar !! Subtraction with a real scalar      (right) procedure , pass ( this ), private :: subl_cscalar => nambu_subl_cscalar !! Subtraction with a complex scalar   (left) procedure , pass ( this ), private :: subr_cscalar => nambu_subr_cscalar !! Subtraction with a complex scalar   (right) procedure , pass ( this ), private :: subl_cmatrix => nambu_subl_cmatrix !! Subtraction with a complex matrix   (left) procedure , pass ( this ), private :: subr_cmatrix => nambu_subr_cmatrix !! Subtraction with a complex matrix   (right) ! Specific implementations of multiplication procedure , pass ( this ), private :: mul_nambu => nambu_mul_nambu !! Multiplication by a nambu object procedure , pass ( this ), private :: mull_rscalar => nambu_mull_rscalar !! Multiplication by a real scalar     (left) procedure , pass ( this ), private :: mulr_rscalar => nambu_mulr_rscalar !! Multiplication by a real scalar     (right) procedure , pass ( this ), private :: mull_cscalar => nambu_mull_cscalar !! Multiplication by a complex scalar  (left) procedure , pass ( this ), private :: mulr_cscalar => nambu_mulr_cscalar !! Multiplication by a complex scalar  (right) procedure , pass ( this ), private :: mull_cmatrix => nambu_mull_cmatrix !! Multiplication by a complex matrix  (left) procedure , pass ( this ), private :: mulr_cmatrix => nambu_mulr_cmatrix !! Multiplication by a complex matrix  (right) ! Specific implementations of division procedure , pass ( this ), private :: divr_rscalar => nambu_divr_rscalar !! Division by a real scalar           (right) procedure , pass ( this ), private :: divr_cscalar => nambu_divr_cscalar !! Division by a complex scalar        (right) ! Specific implementations of exponentiation procedure , pass ( this ), private :: expr_iscalar => nambu_expr_iscalar !! Exponentiation by an integer        (right) end type ! Public interfaces interface inverse !! Matrix inverse module procedure nambu_inv end interface interface trace !! Matrix trace module procedure nambu_trace end interface interface sum !! Matrix sum module procedure nambu_sum end interface interface conjg !! Complex conjugation module procedure nambu_conjg end interface interface nambuv !! Construct basis matrices module procedure nambuv_scalar , nambuv_vector end interface contains !--------------------------------------------------------------------------------! !                            SPECIFIC CONSTRUCTORS                               ! !--------------------------------------------------------------------------------! pure function nambuv_scalar ( n ) result ( r ) !! Constructs basis matrix number n in spin-nambu space. integer , intent ( in ) :: n type ( nambu ) :: r select case ( n ) case ( 0 ) ! Basis matrix τ₀σ₀ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli0 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli0 % matrix case ( 1 ) ! Basis matrix τ₀σ₁ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli1 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli1 % matrix case ( 2 ) ! Basis matrix τ₀σ₂ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli2 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli2 % matrix case ( 3 ) ! Basis matrix τ₀σ₃ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli3 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli3 % matrix case ( 4 ) ! Basis matrix τ₃σ₀ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli0 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli0 % matrix case ( 5 ) ! Basis matrix τ₃σ₁ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli1 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli1 % matrix case ( 6 ) ! Basis matrix τ₃σ₂ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli2 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli2 % matrix case ( 7 ) ! Basis matrix τ₃σ₃ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli3 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli3 % matrix end select end function pure function nambuv_vector ( v ) result ( r ) !! Constructs a matrix representation of a vector. real ( wp ), dimension ( 1 : 3 ), intent ( in ) :: v type ( nambu ) :: r r = v ( 1 ) * nambuv ( 1 ) + v ( 2 ) * nambuv ( 2 ) + v ( 3 ) * nambuv ( 3 ) end function pure function nambu_cons_rscalar ( other ) result ( this ) !! Constructs a nambu object from a real scalar. real ( wp ), intent ( in ) :: other type ( nambu ) :: this this = other end function pure function nambu_cons_cscalar ( other ) result ( this ) !! Constructs a nambu object from a complex scalar. complex ( wp ), intent ( in ) :: other type ( nambu ) :: this this = other end function pure function nambu_cons_cmatrix ( other ) result ( this ) !! Constructs a nambu object from a complex matrix. complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: this this = other end function pure function nambu_cons_nambu ( other ) result ( this ) !! Constructs a nambu object from an existing one. type ( nambu ), intent ( in ) :: other type ( nambu ) :: this this = other end function !--------------------------------------------------------------------------------! !                         SPECIFIC IMPORT PROCEDURES                             ! !--------------------------------------------------------------------------------! pure subroutine nambu_assr_rscalar ( this , other ) !! Imports data to a nambu object from a real scalar. class ( nambu ), intent ( inout ) :: this real ( wp ), intent ( in ) :: other this % matrix = other * identity ( 4 ) end subroutine pure subroutine nambu_assr_cscalar ( this , other ) !! Imports data to a nambu object from a complex scalar. class ( nambu ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other this % matrix = other * identity ( 4 ) end subroutine pure subroutine nambu_assr_cmatrix ( this , other ) !! Imports data to a nambu object from a complex matrix. class ( nambu ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) this % matrix = other end subroutine !--------------------------------------------------------------------------------! !                         SPECIFIC EXPORT PROCEDURES                             ! !--------------------------------------------------------------------------------! pure subroutine nambu_assl_cmatrix ( other , this ) !! Exports data from a nambu object to a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( out ) :: other ( 4 , 4 ) other = this % matrix end subroutine !--------------------------------------------------------------------------------! !                     SPECIFIC EXPONENTIATION PROCEDURES                         ! !--------------------------------------------------------------------------------! pure function nambu_expr_iscalar ( this , other ) result ( r ) !! Exponentiates the nambu object, where the power is a positive integer. class ( nambu ), intent ( in ) :: this integer , intent ( in ) :: other type ( nambu ) :: r integer :: n r = this do n = 2 , other r % matrix = r % matrix * this end do end function !--------------------------------------------------------------------------------! !                     SPECIFIC MULTIPLICATION PROCEDURES                         ! !--------------------------------------------------------------------------------! elemental pure function nambu_mul_nambu ( this , other ) result ( r ) !! Defines multiplication of two nambu matrices. class ( nambu ), intent ( in ) :: this class ( nambu ), intent ( in ) :: other type ( nambu ) :: r r % matrix = matmul ( this % matrix , other % matrix ) end function pure function nambu_mull_rscalar ( other , this ) result ( r ) !! Defines left multiplication of a nambu matrix by a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * this % matrix end function pure function nambu_mulr_rscalar ( this , other ) result ( r ) !! Defines right multiplication of a nambu matrix by a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix * other end function pure function nambu_mull_cscalar ( other , this ) result ( r ) !! Defines left multiplication of a nambu matrix by a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * this % matrix end function function nambu_mulr_cscalar ( this , other ) result ( r ) !! Defines right multiplication of a nambu matrix by a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix * other end function pure function nambu_mull_cmatrix ( other , this ) result ( r ) !! Defines left multiplication of a nambu matrix by a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = matmul ( other , this % matrix ) end function pure function nambu_mulr_cmatrix ( this , other ) result ( r ) !! Defines right multiplication of a nambu matrix by a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = matmul ( this % matrix , other ) end function !--------------------------------------------------------------------------------! !                        SPECIFIC DIVISION PROCEDURES                            ! !--------------------------------------------------------------------------------! pure function nambu_divr_rscalar ( this , other ) result ( r ) !! Defines division of a nambu matrix by a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix / other end function pure function nambu_divr_cscalar ( this , other ) result ( r ) !! Defines division of a nambu matrix by a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix / other end function !--------------------------------------------------------------------------------! !                        SPECIFIC ADDITION PROCEDURES                            ! !--------------------------------------------------------------------------------! elemental pure function nambu_add_nambu ( this , other ) result ( r ) !! Defines addition of two nambu matrices. class ( nambu ), intent ( in ) :: this class ( nambu ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix + other % matrix end function pure function nambu_addl_rscalar ( other , this ) result ( r ) !! Defines left addition of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) + this % matrix end function pure function nambu_addr_rscalar ( this , other ) result ( r ) !! Defines right addition of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix + other * identity ( 4 ) end function pure function nambu_addl_cscalar ( other , this ) result ( r ) !! Defines left addition of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) + this % matrix end function pure function nambu_addr_cscalar ( this , other ) result ( r ) !! Defines right addition of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix + other * identity ( 4 ) end function pure function nambu_addl_cmatrix ( other , this ) result ( r ) !! Defines left addition of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = other + this % matrix end function pure function nambu_addr_cmatrix ( this , other ) result ( r ) !! Defines right addition of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = this % matrix + other end function !--------------------------------------------------------------------------------! !                       SPECIFIC SUBTRACTION PROCEDURES                          ! !--------------------------------------------------------------------------------! elemental pure function nambu_sub_nambu ( this , other ) result ( r ) !! Defines subtraction of two nambu matrices. class ( nambu ), intent ( in ) :: this class ( nambu ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix - other % matrix end function pure function nambu_subl_rscalar ( other , this ) result ( r ) !! Defines left subtraction of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) - this % matrix end function pure function nambu_subr_rscalar ( this , other ) result ( r ) !! Defines right subtraction of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix - other * identity ( 4 ) end function pure function nambu_subl_cscalar ( other , this ) result ( r ) !! Defines left subtraction of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) - this % matrix end function pure function nambu_subr_cscalar ( this , other ) result ( r ) !! Defines right subtraction of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix - other * identity ( 4 ) end function pure function nambu_subl_cmatrix ( other , this ) result ( r ) !! Defines left subtraction of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = other - this % matrix end function pure function nambu_subr_cmatrix ( this , other ) result ( r ) !! Defines right subtraction of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = this % matrix - other end function !--------------------------------------------------------------------------------! !                                MATRIX ALGEBRA                                  ! !--------------------------------------------------------------------------------! elemental pure function nambu_conjg ( this ) result ( r ) !! Calculate the complex conjugate of the nambu matrix. class ( nambu ), intent ( in ) :: this type ( nambu ) :: r r % matrix = conjg ( this % matrix ) end function elemental pure function nambu_trace ( this ) result ( r ) !! Calculate the trace of the nambu matrix. class ( nambu ), intent ( in ) :: this complex ( wp ) :: r r = this % matrix ( 1 , 1 ) + this % matrix ( 2 , 2 ) + this % matrix ( 3 , 3 ) + this % matrix ( 4 , 4 ) end function pure function nambu_inv ( this ) result ( r ) !! Calculate the inverse of the nambu matrix. class ( nambu ), intent ( in ) :: this type ( nambu ) :: r r % matrix = inverse ( this % matrix ) end function pure function nambu_sum ( this ) result ( r ) !! Calculate the sum of an array of nambu matrices. class ( nambu ), intent ( in ) :: this (:) type ( nambu ) :: r integer :: n do n = 1 , size ( this ) r % matrix = r % matrix + this ( n ) % matrix end do end function end module","tags":"","loc":"sourcefile/nambu.f.html","title":"nambu.f – ​"},{"text":"Contents Modules matrix_m Source Code matrix.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file defines functions that perform some common matrix operations. module matrix_m use :: basic_m contains pure function identity ( n ) result ( R ) !! Constructs an n×n identity matrix. integer , intent ( in ) :: n !! Matrix dimension real ( wp ), dimension ( n , n ) :: R !! Identity matrix [n×n] integer :: i , j ! Initialize by exploiting integer arithmetic to avoid multiple passes do i = 1 , n do j = 1 , n R ( j , i ) = ( i / j ) * ( j / i ) end do end do end function pure function matrix_inverse_re ( A ) result ( R ) !! Wrapper for matrix_inverse_cx that allows the procedure to be used for real matrices. real ( wp ), dimension (:,:), intent ( in ) :: A !! Matrix A [n×n] real ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Matrix R=A¯¹ R = re ( matrix_inverse_cx ( cx ( A ))) end function pure function matrix_inverse_cx ( A ) result ( R ) !! Invert a square n×n matrix using Gauss-Jordan elimination with partial pivoting. !! In the special case n=2, the inverse is evaluated using a cofactoring algorithm. !! [This implementation is based on Algorithm #2 in \"Efficient matrix inversion via !! Gauss-Jordan elimination and its parallelization\" by E.S. Quintana et al. (1998)] complex ( wp ), dimension (:,:), intent ( in ) :: A !! Matrix A [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Matrix R=A¯¹ integer , dimension ( size ( A , 1 )) :: P complex ( wp ) :: Q integer :: i , j select case ( size ( A , 1 )) case ( 1 ) ! Trivial case R ( 1 , 1 ) = 1 / A ( 1 , 1 ) case ( 2 ) ! Inverse determinant Q = 1 / ( A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 )) ! Inverse matrix R ( 1 , 1 ) = + Q * A ( 2 , 2 ) R ( 2 , 1 ) = - Q * A ( 2 , 1 ) R ( 1 , 2 ) = - Q * A ( 1 , 2 ) R ( 2 , 2 ) = + Q * A ( 1 , 1 ) case default ! Permutation array P = [ ( i , i = 1 , size ( A , 1 ) ) ] ! Matrix copy R = A ! Matrix inversion do i = 1 , size ( A , 1 ) ! Pivoting procedure j = ( i - 1 ) + maxloc ( abs ( A ( i :, i )), 1 ) P ([ i , j ]) = P ([ j , i ]) R ([ i , j ],:) = R ([ j , i ],:) ! Jordan transformation Q = R ( i , i ) R (:, i ) = [ R (: i - 1 , i ), ( 0.0_wp , 0.0_wp ), R ( i + 1 :, i )] / ( - Q ) R = R + matmul ( R (:,[ i ]), R ([ i ],:)) R ( i ,:) = [ R ( i ,: i - 1 ), ( 1.0_wp , 0.0_wp ), R ( i , i + 1 :)] / ( + Q ) end do ! Pivot inversion R (:, P ) = R end select end function pure function matrix_trace ( A ) result ( r ) !! Calculate the trace of a general complex matrix. complex ( wp ), dimension (:,:), intent ( in ) :: A !! Matrix [n×m] complex ( wp ) :: r !! r = Tr(A) integer :: n r = 0 do n = 1 , min ( size ( A , 1 ), size ( A , 2 )) r = r + A ( n , n ) end do end function pure function commutator ( A , B ) result ( R ) !! Calculate the commutator between two complex square matrices. complex ( wp ), dimension (:,:), intent ( in ) :: A !! Left  matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( in ) :: B !! Right matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Commutator R = [A,B] R = matmul ( A , B ) - matmul ( B , A ) end function pure function anticommutator ( A , B ) result ( R ) !! Calculate the anticommutator between two complex square matrices. complex ( wp ), dimension (:,:), intent ( in ) :: A !! Left  matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( in ) :: B !! Right matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Anticommutator R = {A,B} R = matmul ( A , B ) + matmul ( B , A ) end function pure function vector_diag ( A ) result ( r ) !! Extract the diagonal of a general complex matrix. complex ( wp ), dimension (:,:), intent ( in ) :: A !! Matrix [n×m] complex ( wp ), dimension ( min ( size ( A , 1 ), size ( A , 2 ))) :: r !! r = Diag(A) integer :: n do n = 1 , size ( r ) r ( n ) = A ( n , n ) end do end function pure function matrix_diag ( A , B ) result ( R ) !! Construct a block-diagonal matrix R from two general matrices A and B. complex ( wp ), dimension (:,:), intent ( in ) :: A !! Left  matrix [n×m] complex ( wp ), dimension (:,:), intent ( in ) :: B !! Right matrix [p×q] complex ( wp ), dimension ( size ( A , 1 ) + size ( B , 1 ), size ( A , 2 ) + size ( B , 2 )) :: R !! R = Diag(A,B) R = 0.0_wp R (: size ( A , 1 ), : size ( A , 2 ) ) = A R ( size ( A , 1 ) + 1 :, size ( A , 2 ) + 1 :) = B end function end module","tags":"","loc":"sourcefile/matrix.f.html","title":"matrix.f – ​"},{"text":"Contents Modules spin_m Source Code spin.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module defines the data type 'spin', which represents 2×2 complex matrices in spin space. The module overloads !> common arithmetic operators to work with the new data type, and defines and exports the Pauli matrices as constants. !> To make it easier to interact with common differential equation solvers, which often operate on real state vectors, !> the assignment operator is overloaded in such a way that 'spin' can be easily imported/exported to a real vector(8). module spin_m use :: math_m private ! Public interface public spin public inverse , trace , conjg , norm2 , sum public pauli , pauli0 , pauli1 , pauli2 , pauli3 ! Type declaration type spin complex ( wp ) :: matrix ( 2 , 2 ) = 0.0_wp !! Encapsulate a spin matrix contains ! Overload constructors and operators generic :: spin => cons_rscalar , cons_cscalar , cons_cmatrix , cons_rvector , cons_spin generic :: assignment ( = ) => assr_rscalar , assr_cscalar , assr_cmatrix , assr_rvector , assl_cmatrix , assl_rvector generic :: operator ( + ) => addl_rscalar , addr_rscalar , addl_cscalar , addr_cscalar , addl_cmatrix , addr_cmatrix , add_spin generic :: operator ( - ) => subl_rscalar , subr_rscalar , subl_cscalar , subr_cscalar , subl_cmatrix , subr_cmatrix , sub_spin generic :: operator ( * ) => mull_rscalar , mulr_rscalar , mull_cscalar , mulr_cscalar , mull_cmatrix , mulr_cmatrix , mul_spin generic :: operator ( / ) => divr_rscalar , divr_cscalar generic :: operator ( ** ) => expr_iscalar ! Specific methods for construction procedure , nopass , private :: cons_spin => spin_cons_spin !! Construction from a spin object procedure , nopass , private :: cons_rscalar => spin_cons_rscalar !! Construction from a real scalar procedure , nopass , private :: cons_cscalar => spin_cons_cscalar !! Construction from a complex scalar procedure , nopass , private :: cons_cmatrix => spin_cons_cmatrix !! Construction from a complex matrix procedure , nopass , private :: cons_rvector => spin_cons_rvector !! Construction from a real vector ! Specific methods for importing the object state ! Specific implementations of assignments procedure , pass ( this ), private :: assr_rscalar => spin_assr_rscalar !! Assign data from a real scalar      (right) procedure , pass ( this ), private :: assr_cscalar => spin_assr_cscalar !! Assign data from a complex scalar   (right) procedure , pass ( this ), private :: assl_cmatrix => spin_assl_cmatrix !! Assign data into a complex matrix   (left) procedure , pass ( this ), private :: assr_cmatrix => spin_assr_cmatrix !! Assign data from a complex matrix   (right) procedure , pass ( this ), private :: assl_rvector => spin_assl_rvector !! Assign data into a real vector      (left) procedure , pass ( this ), private :: assr_rvector => spin_assr_rvector !! Assign data from a real vector      (right) ! Specific implementations of addition procedure , pass ( this ), private :: add_spin => spin_add_spin !! Addition with a spin object procedure , pass ( this ), private :: addl_rscalar => spin_addl_rscalar !! Addition with a real scalar         (left) procedure , pass ( this ), private :: addr_rscalar => spin_addr_rscalar !! Addition with a real scalar         (right) procedure , pass ( this ), private :: addl_cscalar => spin_addl_cscalar !! Addition with a complex scalar      (left) procedure , pass ( this ), private :: addr_cscalar => spin_addr_cscalar !! Addition with a complex scalar      (right) procedure , pass ( this ), private :: addl_cmatrix => spin_addl_cmatrix !! Addition with a complex matrix      (left) procedure , pass ( this ), private :: addr_cmatrix => spin_addr_cmatrix !! Addition with a complex matrix      (right) ! Specific implementations of subtraction procedure , pass ( this ), private :: sub_spin => spin_sub_spin !! Subtraction with a spin object procedure , pass ( this ), private :: subl_rscalar => spin_subl_rscalar !! Subtraction with a real scalar      (left) procedure , pass ( this ), private :: subr_rscalar => spin_subr_rscalar !! Subtraction with a real scalar      (right) procedure , pass ( this ), private :: subl_cscalar => spin_subl_cscalar !! Subtraction with a complex scalar   (left) procedure , pass ( this ), private :: subr_cscalar => spin_subr_cscalar !! Subtraction with a complex scalar   (right) procedure , pass ( this ), private :: subl_cmatrix => spin_subl_cmatrix !! Subtraction with a complex matrix   (left) procedure , pass ( this ), private :: subr_cmatrix => spin_subr_cmatrix !! Subtraction with a complex matrix   (right) ! Specific implementations of multiplication procedure , pass ( this ), private :: mul_spin => spin_mul_spin !! Multiplication by a spin object procedure , pass ( this ), private :: mull_rscalar => spin_mull_rscalar !! Multiplication by a real scalar     (left) procedure , pass ( this ), private :: mulr_rscalar => spin_mulr_rscalar !! Multiplication by a real scalar     (right) procedure , pass ( this ), private :: mull_cscalar => spin_mull_cscalar !! Multiplication by a complex scalar  (left) procedure , pass ( this ), private :: mulr_cscalar => spin_mulr_cscalar !! Multiplication by a complex scalar  (right) procedure , pass ( this ), private :: mull_cmatrix => spin_mull_cmatrix !! Multiplication by a complex matrix  (left) procedure , pass ( this ), private :: mulr_cmatrix => spin_mulr_cmatrix !! Multiplication by a complex matrix  (right) ! Specific implementations of division procedure , pass ( this ), private :: divr_rscalar => spin_divr_rscalar !! Division by a real scalar           (right) procedure , pass ( this ), private :: divr_cscalar => spin_divr_cscalar !! Division by a complex scalar        (right) ! Specific implementations of exponentiation procedure , pass ( this ), private :: expr_iscalar => spin_expr_iscalar !! Exponentiation by an integer        (right) end type ! Public interfaces interface inverse !! Matrix inverse module procedure spin_inv end interface interface trace !! Matrix trace module procedure spin_trace end interface interface sum !! Matrix sum module procedure spin_sum end interface interface conjg !! Complex conjugation module procedure spin_conjg end interface interface norm2 !! Matrix norm module procedure spin_norm end interface ! Exported constants type ( spin ), parameter :: pauli0 = spin ( reshape ([ ( 1 , 0 ), ( 0 , 0 ), ( 0 , 0 ), ( 1 , 0 ) ], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter :: pauli1 = spin ( reshape ([ ( 0 , 0 ), ( 1 , 0 ), ( 1 , 0 ), ( 0 , 0 ) ], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter :: pauli2 = spin ( reshape ([ ( 0 , 0 ), ( 0 , - 1 ), ( 0 , 1 ), ( 0 , 0 ) ], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter :: pauli3 = spin ( reshape ([ ( 1 , 0 ), ( 0 , 0 ), ( 0 , 0 ), ( - 1 , 0 ) ], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter , dimension ( 0 : 3 ) :: pauli = [ pauli0 , pauli1 , pauli2 , pauli3 ] contains !--------------------------------------------------------------------------------! !                            SPECIFIC CONSTRUCTORS                               ! !--------------------------------------------------------------------------------! pure function spin_cons_rscalar ( other ) result ( this ) !! Constructs a spin object from a real scalar. real ( wp ), intent ( in ) :: other type ( spin ) :: this this = other end function pure function spin_cons_cscalar ( other ) result ( this ) !! Constructs a spin object from a complex scalar. complex ( wp ), intent ( in ) :: other type ( spin ) :: this this = other end function pure function spin_cons_cmatrix ( other ) result ( this ) !! Constructs a spin object from a complex matrix. complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: this this = other end function pure function spin_cons_rvector ( other ) result ( this ) !! Constructs a spin object from a real vector. real ( wp ), intent ( in ) :: other ( 8 ) type ( spin ) :: this this = other end function pure function spin_cons_spin ( other ) result ( this ) !! Constructs a spin object from an existing one. type ( spin ), intent ( in ) :: other type ( spin ) :: this this = other end function !--------------------------------------------------------------------------------! !                         SPECIFIC IMPORT PROCEDURES                             ! !--------------------------------------------------------------------------------! pure subroutine spin_assr_rscalar ( this , other ) !! Imports data to a spin object from a real scalar. class ( spin ), intent ( inout ) :: this real ( wp ), intent ( in ) :: other this % matrix = other * pauli0 % matrix end subroutine pure subroutine spin_assr_cscalar ( this , other ) !! Imports data to a spin object from a complex scalar. class ( spin ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other this % matrix = other * pauli0 % matrix end subroutine pure subroutine spin_assr_cmatrix ( this , other ) !! Imports data to a spin object from a complex matrix. class ( spin ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) this % matrix = other end subroutine pure subroutine spin_assr_rvector ( this , other ) !! Imports data to a spin object from a real vector. class ( spin ), intent ( inout ) :: this real ( wp ), intent ( in ) :: other ( 8 ) this % matrix = cx ( reshape ( other ( 1 : 7 : 2 ),[ 2 , 2 ], order = [ 2 , 1 ]),& reshape ( other ( 2 : 8 : 2 ),[ 2 , 2 ], order = [ 2 , 1 ])) end subroutine !--------------------------------------------------------------------------------! !                         SPECIFIC EXPORT PROCEDURES                             ! !--------------------------------------------------------------------------------! pure subroutine spin_assl_cmatrix ( other , this ) !! Exports data from a spin object to a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( out ) :: other ( 2 , 2 ) other = this % matrix end subroutine pure subroutine spin_assl_rvector ( other , this ) !! Exports data from a spin object to a real vector. class ( spin ), intent ( in ) :: this real ( wp ), intent ( out ) :: other ( 8 ) other ( 1 : 7 : 2 ) = re ([ this % matrix ( 1 ,:), this % matrix ( 2 ,:) ]) other ( 2 : 8 : 2 ) = im ([ this % matrix ( 1 ,:), this % matrix ( 2 ,:) ]) end subroutine !--------------------------------------------------------------------------------! !                     SPECIFIC EXPONENTIATION PROCEDURES                         ! !--------------------------------------------------------------------------------! pure function spin_expr_iscalar ( this , other ) result ( r ) !! Exponentiates the spin object, where the power is a positive integer. class ( spin ), intent ( in ) :: this integer , intent ( in ) :: other type ( spin ) :: r integer :: n r = this do n = 2 , other r % matrix = r % matrix * this end do end function !--------------------------------------------------------------------------------! !                     SPECIFIC MULTIPLICATION PROCEDURES                         ! !--------------------------------------------------------------------------------! elemental pure function spin_mul_spin ( this , other ) result ( r ) !! Defines multiplication of two spin matrices. class ( spin ), intent ( in ) :: this class ( spin ), intent ( in ) :: other type ( spin ) :: r r % matrix = matmul ( this % matrix , other % matrix ) end function pure function spin_mull_rscalar ( other , this ) result ( r ) !! Defines left multiplication of a spin matrix by a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * this % matrix end function pure function spin_mulr_rscalar ( this , other ) result ( r ) !! Defines right multiplication of a spin matrix by a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix * other end function pure function spin_mull_cscalar ( other , this ) result ( r ) !! Defines left multiplication of a spin matrix by a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * this % matrix end function function spin_mulr_cscalar ( this , other ) result ( r ) !! Defines right multiplication of a spin matrix by a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix * other end function pure function spin_mull_cmatrix ( other , this ) result ( r ) !! Defines left multiplication of a spin matrix by a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = matmul ( other , this % matrix ) end function pure function spin_mulr_cmatrix ( this , other ) result ( r ) !! Defines right multiplication of a spin matrix by a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = matmul ( this % matrix , other ) end function !--------------------------------------------------------------------------------! !                        SPECIFIC DIVISION PROCEDURES                            ! !--------------------------------------------------------------------------------! pure function spin_divr_rscalar ( this , other ) result ( r ) !! Defines division of a spin matrix by a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix / other end function pure function spin_divr_cscalar ( this , other ) result ( r ) !! Defines division of a spin matrix by a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix / other end function !--------------------------------------------------------------------------------! !                        SPECIFIC ADDITION PROCEDURES                            ! !--------------------------------------------------------------------------------! elemental pure function spin_add_spin ( this , other ) result ( r ) !! Defines addition of two spin matrices. class ( spin ), intent ( in ) :: this class ( spin ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix + other % matrix end function pure function spin_addl_rscalar ( other , this ) result ( r ) !! Defines left addition of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix + this % matrix end function pure function spin_addr_rscalar ( this , other ) result ( r ) !! Defines right addition of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix + other * pauli0 % matrix end function pure function spin_addl_cscalar ( other , this ) result ( r ) !! Defines left addition of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix + this % matrix end function pure function spin_addr_cscalar ( this , other ) result ( r ) !! Defines right addition of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix + other * pauli0 % matrix end function pure function spin_addl_cmatrix ( other , this ) result ( r ) !! Defines left addition of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = other + this % matrix end function pure function spin_addr_cmatrix ( this , other ) result ( r ) !! Defines right addition of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = this % matrix + other end function !--------------------------------------------------------------------------------! !                       SPECIFIC SUBTRACTION PROCEDURES                          ! !--------------------------------------------------------------------------------! elemental pure function spin_sub_spin ( this , other ) result ( r ) !! Defines subtraction of two spin matrices. class ( spin ), intent ( in ) :: this class ( spin ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix - other % matrix end function pure function spin_subl_rscalar ( other , this ) result ( r ) !! Defines left subtraction of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix - this % matrix end function pure function spin_subr_rscalar ( this , other ) result ( r ) !! Defines right subtraction of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix - other * pauli0 % matrix end function pure function spin_subl_cscalar ( other , this ) result ( r ) !! Defines left subtraction of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix - this % matrix end function pure function spin_subr_cscalar ( this , other ) result ( r ) !! Defines right subtraction of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix - other * pauli0 % matrix end function pure function spin_subl_cmatrix ( other , this ) result ( r ) !! Defines left subtraction of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = other - this % matrix end function pure function spin_subr_cmatrix ( this , other ) result ( r ) !! Defines right subtraction of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = this % matrix - other end function !--------------------------------------------------------------------------------! !                                MATRIX ALGEBRA                                  ! !--------------------------------------------------------------------------------! elemental pure function spin_norm ( this ) result ( r ) !! Calculate the Frobenius norm of the spin matrix. class ( spin ), intent ( in ) :: this real ( wp ) :: r , w ( 8 ) w = this r = norm2 ( w ) end function elemental pure function spin_conjg ( this ) result ( r ) !! Calculate the complex conjugate of the spin matrix. class ( spin ), intent ( in ) :: this type ( spin ) :: r r % matrix = conjg ( this % matrix ) end function elemental pure function spin_trace ( this ) result ( r ) !! Calculate the trace of the spin matrix. class ( spin ), intent ( in ) :: this complex ( wp ) :: r r = this % matrix ( 1 , 1 ) + this % matrix ( 2 , 2 ) end function pure function spin_inv ( this ) result ( r ) !! Calculate the inverse of the spin matrix. class ( spin ), intent ( in ) :: this type ( spin ) :: r r % matrix = inverse ( this % matrix ) end function pure function spin_sum ( this ) result ( r ) !! Calculate the sum of an array of spin matrices. class ( spin ), intent ( in ) :: this (:) type ( spin ) :: r integer :: n do n = 1 , size ( this ) r % matrix = r % matrix + this ( n ) % matrix end do end function end module","tags":"","loc":"sourcefile/spin.f.html","title":"spin.f – ​"},{"text":"Contents Modules math_m Source Code math.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file provides a common interface to a large library of mathematical !> functions and subroutines. See the documentation of individual interfaces !> below for more information about the contents of the mathematical library. module math_m use :: basic_m use :: calculus_m use :: matrix_m private !------------------------------------------------------------ ! Public interface !------------------------------------------------------------ ! Floating-point precision public :: sp , dp , qp , wp ! Numerical constants public :: inf , eps , pi ! Basic routines public :: unitvector , nonzero , re , im , cx , arg ! Matrix routines public :: trace , diag , inverse , identity , commutator , anticommutator ! Calculus routines public :: mean , differentiate , integrate , interpolate , linspace !------------------------------------------------------------ ! Interfaces for working with matrices !------------------------------------------------------------ interface trace !! Public interface for functions that calculate a matrix trace. module procedure matrix_trace ! Trace of a matrix end interface interface inverse !! Public interface for functions that calculate a matrix inverse. module procedure matrix_inverse_re , & ! Inverse of a real matrix matrix_inverse_cx ! Inverse of a complex matrix end interface interface diag !! Public interface for functions that deal with matrix diagonals. module procedure matrix_diag , & ! Construct a diagonal matrix vector_diag ! Extract a matrix diagonal end interface !------------------------------------------------------------ ! Interfaces for calculus routines !------------------------------------------------------------ interface mean !! Public interface for routines that calculate the mean value. module procedure mean_array_re , & ! Mean of a real array mean_array_cx ! Mean of a complex array end interface interface differentiate !! Public interface for various differentiation routines. module procedure differentiate_array_re , & ! Derivative of a real array differentiate_array_cx ! Derivative of a complex array end interface interface integrate !! Public interface for various integration routines. module procedure integrate_array_re , & ! Trapezoid integration of a real array integrate_array_cx , & ! Trapezoid integration of a complex array integrate_range_re , & ! Interpolated integration of a real array integrate_range_cx ! Interpolated integration of a complex array end interface interface interpolate !! Public interface for various interpolation routines. module procedure interpolate_point_re , & ! Interpolate a scalar function from a real array to a point interpolate_point_cx , & ! Interpolate a scalar function from a complex array to a point interpolate_array_re , & ! Interpolate a scalar function from a real array to an array interpolate_array_cx , & ! Interpolate a scalar function from a complex array to an array interpolate_point_matrix_re ! Interpolate a matrix function from a real array array to a point end interface interface linspace !! Public interface for routines that initialize arrays. module procedure linspace_array_re ! Linearly spaced real numbers end interface end module","tags":"","loc":"sourcefile/math.f.html","title":"math.f – ​"},{"text":"Contents Modules structure_m Source Code structure.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines a data type 'structure', which is useful for constructing and using multilayer hybrid structures. It !> also exports the type definitions and constructors for all class(material) types, although these should rarely be needed. module structure_m use :: stdio_m use :: condmat_m use :: material_m use :: conductor_m use :: superconductor_m use :: ferromagnet_m use :: halfmetal_m private ! Export class(material) types public material , conductor , superconductor , ferromagnet , halfmetal ! Type declaration type , public :: structure ! Endpoints of the contained linked list class ( material ), pointer :: a => null () !! First material class ( material ), pointer :: b => null () !! Last  material ! Output units for physical observables integer , allocatable :: supercurrent !! Output unit (allocate to write supercurrents  to file) integer , allocatable :: lossycurrent !! Output unit (allocate to write lossycurrents  to file) integer , allocatable :: accumulation !! Output unit (allocate to write accumulations  to file) integer , allocatable :: correlation !! Output unit (allocate to write correlations   to file) integer , allocatable :: magnetization !! Output unit (allocate to write magnetizations to file) integer , allocatable :: distribution !! Output unit (allocate to write distributions  to file) integer , allocatable :: density !! Output unit (allocate to write density of states to file) contains ! Basic construction and management procedure :: push => structure_push !! Construct a single layer procedure :: conf => structure_conf !! Configure a single layer procedure :: cmap => structure_cmap !! Configure  all layers procedure :: fmap => structure_fmap !! Manipulate all layers ! Manipulation of the physical state procedure :: initialize => structure_initialize !! Reset the physical state procedure :: save => structure_save !! Save the physical state procedure :: load => structure_load !! Load the physical state procedure :: update => structure_update !! Update the physical state procedure :: update_prehook => structure_update_prehook !! Execute all update prehooks procedure :: update_posthook => structure_update_posthook !! Execute all update posthooks procedure :: converge => structure_converge !! Update until convergence procedure :: write => structure_write !! Write out observables ! Auxiliary helper functions procedure :: difference => structure_difference !! Check how much the physical state changes procedure :: materials => structure_materials !! Check the number of enabled materials procedure :: selfconsistency => structure_selfconsistency !! Whether selfconsistency iteration is required procedure :: superconductors => structure_superconductors !! Check the number of enables superconductors procedure :: chargeviolation => structure_chargeviolation !! Check the violation of charge conservation procedure :: gap => structure_gap !! Check the minimum superconducting gap end type ! Type constructor interface structure module procedure structure_construct end interface ! Interface for external routines that can be mapped onto class(material) objects abstract interface subroutine mappable ( ptr ) use :: material_m class ( material ), pointer :: ptr end subroutine end interface ! Interface for external routines that can be used by convergence() calls abstract interface subroutine hook () end subroutine end interface contains impure subroutine structure_push ( this , string ) !! Constructs a new class(material) object at the bottom of the multilayer stack. class ( structure ), intent ( inout ) :: this character ( * ), intent ( in ) :: string ! Construct the material if (. not . associated ( this % b )) then ! This is the first layer in the structure call alloc ( this % b , string ) call this % b % construct this % a => this % b else ! This is not the first layer in the structure call alloc ( this % b % material_b , string ) call this % b % material_b % construct this % b % material_b % material_a => this % b this % b => this % b % material_b end if ! Status information write ( stdout , * ) write ( stdout , * ) '[' // string // ']' contains subroutine alloc ( ptr , str ) !! Allocates memory for a new material layer. class ( material ), pointer :: ptr character ( * ) :: str select case ( str ) case ( 'halfmetal' ) allocate ( halfmetal :: ptr ) case ( 'ferromagnet' ) allocate ( ferromagnet :: ptr ) case ( 'superconductor' ) allocate ( superconductor :: ptr ) case ( 'conductor' ) allocate ( conductor :: ptr ) case default call error ( 'Material type \"' // trim ( str ) // '\" unknown!' ) end select end subroutine end subroutine impure subroutine structure_conf ( this , key , val ) !! Configures the last material pushed to the multilayer stack. !! !! @TODO !!   Add global config options for the entire stack. class ( structure ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val character ( 24 ) :: str ! Status information write ( str , * ) key // ':' write ( stdout , * ) str // val ! Configuration procedure if (. not . associated ( this % b )) then ! Global configuration since no materials exist select case ( key ) case default call warning ( \"Unknown structure option '\" // key // \"' ignored.\" ) end select else ! Local configuration of only the last material call this % b % conf ( key , val ) end if end subroutine impure subroutine structure_cmap ( this , key , val ) !! Maps a configuration option onto each element of the multilayer stack. class ( structure ), intent ( inout ) :: this character ( * ), intent ( in ) :: key class ( * ), intent ( in ) :: val character ( 1024 ) :: str ! Parse the config option str = '' select type ( val ) type is ( character ( * )) str = val type is ( logical ) write ( str , '(l1)' ) val type is ( integer ) write ( str , '(i0)' ) val type is ( real ( wp )) write ( str , '(g0)' ) val end select ! Map it onto each material call this % fmap ( conf , every = . true .) contains subroutine conf ( m ) class ( material ), pointer :: m ! Configure the material call m % conf ( key , trim ( adjustl ( str ))) end subroutine end subroutine impure subroutine structure_fmap ( this , routine , every ) !! Maps a subroutine onto each element of the multilayer stack. class ( structure ), target :: this class ( material ), pointer :: ptr procedure ( mappable ) :: routine logical , optional :: every ! Traverse the structure from top to bottom call top ( ptr ) do while ( associated ( ptr )) call routine ( ptr ) call next ( ptr ) end do contains function check ( ptr ) result ( skip ) ! Check if a material layer should be skipped. class ( material ), pointer :: ptr logical :: skip logical :: every_ ! Check for optional arguments if ( present ( every )) then every_ = every else every_ = . false . end if ! Decide whether to skip this layer if ( every_ ) then ! Process every layer in the stack skip = . false . else if (. not . associated ( ptr )) then ! There are no layers left to skip skip = . false . else ! Decide based on the user config skip = ptr % order <= 0 end if end function subroutine top ( ptr ) ! Find the first enabled material in the stack. class ( material ), pointer :: ptr ptr => this % a do while ( check ( ptr )) ptr => ptr % material_b end do end subroutine subroutine next ( ptr ) ! Find the next enabled material in the stack. class ( material ), pointer :: ptr if ( associated ( ptr )) then ptr => ptr % material_b do while ( check ( ptr )) ptr => ptr % material_b end do end if end subroutine end subroutine impure function structure_gap ( this ) result ( gap ) !! Obtains the mean gap in the enabled superconductor. If there are multiple such !! superconductors in the junction, then it returns the minimum of the mean gaps. class ( structure ), target :: this real ( wp ) :: gap logical :: found ! Initialize variables gap = huge ( real ( wp )) found = . false . ! Check the gaps call this % fmap ( find ) ! If no superconductor was found, raise an error if (. not . found ) then call error ( 'No superconductors with order > 0 in the junction!' ) end if contains subroutine find ( m ) class ( material ), pointer :: m select type ( m ) class is ( superconductor ) gap = min ( gap , sum ( abs ( m % gap_function )) / max ( 1 , size ( m % gap_function ))) found = . true . end select end subroutine end function impure subroutine structure_initialize ( this ) !! Initializes the state of the entire multilayer stack. class ( structure ), target :: this ! Initialize all material states call this % fmap ( initialize , every = . true .) contains subroutine initialize ( m ) class ( material ), pointer :: m call m % initialize end subroutine end subroutine impure subroutine structure_save ( this ) !! Saves the state of the entire multilayer stack. class ( structure ), target :: this ! Save all material states call this % fmap ( save ) contains subroutine save ( m ) class ( material ), pointer :: m call m % save end subroutine end subroutine impure subroutine structure_load ( this ) !! Loads the saved state of the multilayer stack. class ( structure ), target :: this ! Load all material states call this % fmap ( load ) contains subroutine load ( m ) class ( material ), pointer :: m call m % load end subroutine end subroutine impure subroutine structure_update ( this , bootstrap ) !! Updates the state of the entire multilayer stack. class ( structure ), target :: this logical , optional :: bootstrap integer :: order ! Update materials in order do order = 1 , 16 call this % fmap ( update ) end do contains subroutine update ( m ) class ( material ), pointer :: m if ( m % order == order ) then call m % update ( bootstrap ) end if end subroutine end subroutine impure subroutine structure_converge ( this , threshold , iterations , bootstrap , prehook , posthook ) !! Performs a convergence procedure, where the state of every material in the stack !! is repeatedly updated until the residuals drop below some specified threshold !! and/or a certain number of iterations have been performed. If bootstrap is set !! to true, the selfconsistency equations will only be solved once at the end, but !! not inbetween the individual iterations. If a prehook and/or posthook is given, !! those subroutines will be executed before/after each iteration of the update. class ( structure ), target :: this real ( wp ), optional :: threshold real ( wp ) :: threshold_ integer , optional :: iterations integer :: iterations_ logical , optional :: bootstrap logical :: bootstrap_ procedure ( hook ), optional :: prehook procedure ( hook ), optional :: posthook integer :: materials logical :: selfconsistency integer :: n ! Set default arguments threshold_ = 1 iterations_ = 0 bootstrap_ = . false . ! Check optional arguments if ( present ( threshold )) threshold_ = threshold if ( present ( iterations )) iterations_ = iterations if ( present ( bootstrap )) bootstrap_ = bootstrap ! Count the number of materials materials = this % materials () selfconsistency = this % selfconsistency () ! Reset any iteration counters call this % cmap ( 'iteration' , 0 ) ! If we're not bootstrapping, then we wish to execute all posthook actions at least once if (. not . bootstrap_ ) then call this % update_posthook end if ! If we're not bootstrapping, then we have to solve the diffusion equation until convergence. ! If we're bootstrapping, it's only required if we have selfconsistency equations to solve. if ((. not . bootstrap_ ) . or . selfconsistency ) then n = 0 do ! Update counter n = n + 1 ! Status information if ( bootstrap_ ) then call status_head ( 'BOOTSTRAPPING' ) else call status_head ( 'CONVERGING' ) end if call status_body ( 'State difference' , this % difference ()) if (. not . bootstrap_ ) then call status_body ( 'Charge violation' , this % chargeviolation ()) end if if ( present ( prehook )) then call prehook end if call status_body ( 'Iteration' , n ) call status_foot ! Update the material state (non-selfconsistently) call this % update ( bootstrap = bootstrap_ ) ! Write the results to files call this % write ! Extra actions defined by the user if ( present ( posthook )) then call posthook end if ! Exit criterion #1: one iteration is sufficient for convergence if (( materials == 1 ) . and . ( bootstrap_ . or . (. not . selfconsistency ))) then exit end if ! Exit criterion #2: minimum number of iterations reached, ! and the materials converged within specified parameters if (( n >= iterations_ ) . and . ( this % difference () < threshold_ )) then exit end if end do end if end subroutine impure subroutine structure_update_prehook ( this ) !! Silently execute all update prehooks. class ( structure ) :: this ! Traverse all materials call this % fmap ( prehook ) contains subroutine prehook ( ptr ) class ( material ), pointer :: ptr integer :: info ! Disable status messages info = ptr % information if ( ptr % information >= 0 ) then ptr % information = - 1 end if ! Silently run prehooks call ptr % update_prehook ! Reenable status messages ptr % information = info end subroutine end subroutine impure subroutine structure_update_posthook ( this ) !! Silently execute all update posthooks. class ( structure ) :: this ! Traverse all materials call this % fmap ( posthook ) contains subroutine posthook ( ptr ) class ( material ), pointer :: ptr integer :: info ! Disable status messages info = ptr % information if ( ptr % information >= 0 ) then ptr % information = - 1 end if ! Silently run posthooks call ptr % update_posthook ! Reenable status messages ptr % information = info end subroutine end subroutine impure function structure_materials ( this ) result ( num ) !! Checks the number of enabled materials in the multilayer stack. class ( structure ), target :: this integer :: num ! Initialize variables num = 0 ! Count the number of materials call this % fmap ( count ) contains subroutine count ( ptr ) class ( material ), pointer :: ptr num = num + 1 end subroutine end function impure function structure_selfconsistency ( this ) result ( res ) !! Checks whether selfconsistency iteration is required. class ( structure ), target :: this logical :: res ! Initialize variables res = . false . ! Check for materials where selfconsistency iterations are required call this % fmap ( count ) contains subroutine count ( ptr ) class ( material ), pointer :: ptr select type ( ptr ) class is ( superconductor ) res = res . or . ( allocated ( ptr % zeeman )) . or . ( ptr % selfconsistency > 0 ) class is ( ferromagnet ) res = res . or . ( allocated ( ptr % zeeman )) end select end subroutine end function impure function structure_superconductors ( this ) result ( num ) !! Checks the number of selfconsistent superconductors in the multilayer stack. class ( structure ), target :: this integer :: num ! Initialize variables num = 0 ! Count the number of superconductors call this % fmap ( count ) contains subroutine count ( ptr ) class ( material ), pointer :: ptr select type ( ptr ) class is ( superconductor ) if ( ptr % selfconsistency > 0 ) then num = num + 1 end if end select end subroutine end function impure function structure_difference ( this ) result ( difference ) !! Checks how much the multilayer stack has changed recently. class ( structure ), target :: this real ( wp ) :: difference ! Initialization difference = 0 ! Traverse all materials call this % fmap ( check ) contains subroutine check ( m ) class ( material ), pointer :: m ! Accumulate the difference difference = max ( difference , m % difference ) end subroutine end function impure function structure_chargeviolation ( this ) result ( difference ) !! Checks how much the charge current varies with position. Since charge current !! is supposed to be conserved through the junction, this provides a measure of !! charge conservation violation, i.e. if the solution is physically realistic. class ( structure ), target :: this real ( wp ) :: difference real ( wp ) :: minimum real ( wp ) :: maximum ! Set starting values minimum = + inf maximum = - inf ! Traverse all materials to find the most extreme currents call this % fmap ( check ) ! Calculate the difference between these extreme values difference = maximum - minimum contains subroutine check ( m ) class ( material ), pointer :: m ! Determine the charge current extrema maximum = max ( maximum , maxval ( m % supercurrent ( 0 ,:) + m % lossycurrent ( 0 ,:))) minimum = min ( minimum , minval ( m % supercurrent ( 0 ,:) + m % lossycurrent ( 0 ,:))) end subroutine end function impure subroutine structure_write ( this ) !! Writes physical observables to output files. class ( structure ), target :: this real ( wp ) :: a , b ! Initialize variables b = 0 ! Traverse all materials call this % fmap ( writer ) ! Sync data to output files call sync ( this % accumulation ) call sync ( this % supercurrent ) call sync ( this % lossycurrent ) call sync ( this % correlation ) call sync ( this % magnetization ) call sync ( this % distribution ) call sync ( this % density ) contains subroutine sync ( unit ) integer , allocatable , intent ( in ) :: unit if ( allocated ( unit )) then flush ( unit ) rewind ( unit ) end if end subroutine subroutine writer ( ptr ) class ( material ), pointer :: ptr real ( wp ) :: p , z integer :: n , m ! Calculate the endpoints a = b b = b + ptr % length ! Loop over all positions do m = 1 , size ( ptr % location ) ! Calculate current position p = ptr % location ( m ) z = a + ( b - a ) * p ! Write accumulations if ( allocated ( this % accumulation )) then write ( this % accumulation , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % accumulation (:, m ) end if ! Write supercurrents if ( allocated ( this % supercurrent )) then write ( this % supercurrent , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % supercurrent (:, m ) end if ! Write dissipative currents if ( allocated ( this % lossycurrent )) then write ( this % lossycurrent , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % lossycurrent (:, m ) end if ! Write superconducting correlations if ( allocated ( this % correlation )) then write ( this % correlation , '(*(es20.12e3,:,\"\t\"))' ) & z , abs ( ptr % correlation ( m )), arg ( ptr % correlation ( m )) / pi end if ! Write effective magnetizations if ( allocated ( this % magnetization )) then write ( this % magnetization , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % magnetization (:, m ) end if ! Write distribution functions if ( allocated ( this % distribution )) then ! Energies do n = 1 , size ( ptr % energy ) write ( this % distribution , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % energy ( n ), ptr % propagator ( n , m ) % h end do ! Newline write ( this % distribution , '()' ) end if ! Write density of states if ( allocated ( this % density )) then ! Negative energies do n = size ( ptr % energy ), 1 , - 1 write ( this % density , '(*(es20.12e3,:,\"\t\"))' ) & z , - ptr % energy ( n ), ptr % density ( n , m , 4 : 7 ) end do ! Positive energies do n = 1 , size ( ptr % energy ), + 1 write ( this % density , '(*(es20.12e3,:,\"\t\"))' ) & z , + ptr % energy ( n ), ptr % density ( n , m , 0 : 3 ) end do ! Newline write ( this % density , '()' ) end if end do end subroutine end subroutine impure function structure_construct () result ( this ) !! Constructs a multilayer stack from a configuration file. type ( structure ) :: this character ( len = 4096 ) :: file integer :: unit integer :: iostat integer :: status character ( len = 2048 ) :: str , arg integer :: line , i , j , k ! Initialize variables line = 0 unit = 0 iostat = 0 status = 0 ! Open the config file call get_command_argument ( 1 , file , status = status ) if ( status /= 0 ) then call error ( 'Missing the command line argument #1, i.e. the name of configuration file.' ) end if unit = input ( trim ( file )) ! Command arguments call get_command ( str ) write ( stdout , '(a)' ) trim ( str ) ! Status information call status_box ( 'CONFIGURATION' ) ! Read the config file do while ( iostat == 0 ) ! Increase line counter line = line + 1 ! Read one line from file str = '' read ( unit , '(a)' , iostat = iostat ) str ! Strip comments from line i = scan ( str , '#' ) if ( i > 0 ) then str = str (: i - 1 ) end if ! Strip whitespace from line str = trim ( adjustl ( str )) ! Substitute command line arguments i = scan ( str , '{' ) j = scan ( str , '}' ) do while ( i > 0 . and . j - 1 >= i + 1 ) read ( str ( i + 1 : j - 1 ), * , iostat = status ) k if ( status /= 0 ) then call error ( 'Failed to parse parameter ' // str ( i : j ) // ' defined by the configuration file.' ) end if call get_command_argument ( k + 1 , arg , status = status ) if ( status /= 0 ) then write ( arg , '(i0)' ) k + 1 call error ( 'Missing command line argument #' // trim ( arg ) // ', i.e. parameter ' // str ( i : j ) // ' in the config file.' ) end if if ( scan ( trim ( arg ), '+-' ) == 1 ) then ! Escape signed command line arguments str = str (: i - 1 ) // '(' // trim ( arg ) // ')' // str ( j + 1 :) else ! Do not escape unsigned arguments str = str (: i - 1 ) // trim ( arg ) // str ( j + 1 :) end if i = scan ( str , '{' ) j = scan ( str , '}' ) end do ! Construct the material i = scan ( str , '[' ) j = scan ( str , ']' ) if ( i == 1 . and . j > i ) then call this % push ( trim ( adjustl ( str ( i + 1 : j - 1 )))) cycle end if ! Configure the material i = scan ( str , ':' ) if ( i > 0 ) then call this % conf ( trim ( adjustl ( str (: i - 1 ))), trim ( adjustl ( str ( i + 1 :)))) cycle end if ! Check if this line contains garbage if ( str /= '' ) then write ( str , '(i0)' ) line call error ( 'Failed to parse line ' // trim ( str ) // ' in the config file.' ) end if end do ! Close the config file close ( unit = unit ) ! Confirm that there is at least one material layer if ( this % materials () < 1 ) then call error ( 'The material stack described by \"' // file // '\" has no layers with order > 0!' ) end if ! Initialize all materials call this % initialize end function end module","tags":"","loc":"sourcefile/structure.f.html","title":"structure.f – ​"},{"text":"Contents Modules spinactive_m Source Code spinactive.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This submodule is included by conductor.f, and contains the equations which model spin-active interfaces. !> !> @TODO !>   Reimplement shortcut-evaluation of the current for nonmagnetic interfaces. module spinactive_m use :: propagator_m use :: material_m use :: condmat_m private ! Public interface public spinactive ! Type declarations type :: spinactive ! Physical parameters of the interface real ( wp ) :: conductance = 1.0 !! Interfacial conductance real ( wp ) :: polarization = 0.0 !! Interfacial spin-polarization real ( wp ) :: spinmixing = 0.0 !! Interfacial 1st-order spin-mixing real ( wp ) :: secondorder = 0.0 !! Interfacial 2nd-order spin-mixing real ( wp ), dimension ( 1 : 3 ) :: magnetization = [ 0 , 0 , 1 ] !! Interfacial magnetization direction real ( wp ), dimension ( 1 : 3 ) :: misalignment0 = [ 0 , 0 , 0 ] !! Interfacial magnetization misalignment (this  side) real ( wp ), dimension ( 1 : 3 ) :: misalignment1 = [ 0 , 0 , 0 ] !! Interfacial magnetization misalignment (other side) ! Fields used internally by the object type ( nambu ), private :: M !! Magnetization matrix (transmission) type ( nambu ), private :: M0 !! Magnetization matrix (reflection, this  side) type ( nambu ), private :: M1 !! Magnetization matrix (reflection, other side) contains procedure :: diffusion_current => spinactive_diffusion_current procedure :: kinetic_current => spinactive_kinetic_current procedure :: update_prehook => spinactive_update_prehook end type contains impure subroutine spinactive_update_prehook ( this ) !! Updates the internal variables associated with spin-active interfaces. class ( spinactive ), intent ( inout ) :: this ! Transmission magnetization this % M = nambuv ( this % magnetization ) ! Reflection magnetization (this side) this % M0 = this % M if ( nonzero ( this % misalignment0 )) then this % M0 = nambuv ( this % misalignment0 ) end if ! Reflection magnetization (other side) this % M1 = this % M if ( nonzero ( this % misalignment1 )) then this % M1 = nambuv ( this % misalignment1 ) end if end subroutine pure function spinactive_diffusion_current ( this , G0 , G1 ) result ( I ) !! Calculate the matrix current at an interface with spin-active properties. The equations !! implemented here should be valid for an arbitrary interface polarization, and up to 2nd !! order in the transmission probabilities and spin-mixing angles of the interface. class ( spinactive ), intent ( in ) :: this type ( nambu ), intent ( in ) :: G0 , G1 !! Propagator matrices type ( nambu ) :: S0 , S1 !! Matrix expressions type ( nambu ) :: I !! Matrix current ! Evaluate the 1st-order matrix functions S0 = spinactive_current1_transmission ( G1 ) S1 = spinactive_current1_reflection () ! Evaluate the 1st-order matrix current associate ( S => S0 + S1 ) I = ( S * G0 - G0 * S ) end associate ! Calculate the 2nd-order contributions to the matrix current. Note that we make a ! number of simplifications in this implementation. In particular, we assume that ! all interface parameters except the magnetization directions are equal on both ! sides of the interface. We also assume that the spin-mixing angles and tunneling ! probabilities of different channels have standard deviations that are much smaller ! than their mean values, which reduces the number of new fitting parameters to one. if ( abs ( this % secondorder ) > 0 ) then ! Evaluate the 1st-order matrix functions associate ( M1 => this % M1 ) S1 = spinactive_current1_transmission ( G1 * M1 * G1 - M1 ) end associate ! Evaluate the 2nd-order matrix current I = I & + spinactive_current2_transmission () & + spinactive_current2_crossterms () & + spinactive_current2_reflection () end if ! Scale the final result based on conductance I = ( this % conductance / 2 ) * I contains pure function spinactive_current1_transmission ( G ) result ( F ) !! Calculate the 1st-order transmission terms in the matrix current commutator. type ( nambu ), intent ( in ) :: G type ( nambu ) :: F real ( wp ) :: Pr , Pp , Pm associate ( P => this % polarization , M => this % M ) Pr = sqrt ( 1 - P ** 2 ) Pp = 1 + Pr Pm = 1 - Pr F = G + ( P / Pp ) * ( M * G + G * M ) + ( Pm / Pp ) * ( M * G * M ) end associate end function pure function spinactive_current1_reflection () result ( F ) !! Calculate the 1st-order spin-mixing terms in the matrix current commutator. type ( nambu ) :: F associate ( Q => this % spinmixing , M0 => this % M0 ) F = (( 0 , - 1 ) * Q ) * M0 end associate end function pure function spinactive_current2_transmission () result ( I ) !! Calculate the 2nd-order transmission terms in the matrix current. type ( nambu ) :: I associate ( R => this % secondorder , Q => this % spinmixing ) I = ( - 0.50 * R / Q ) * ( S0 * G0 * S0 ) end associate end function pure function spinactive_current2_reflection () result ( I ) !! Calculate the 2nd-order spin-mixing terms in the matrix current. type ( nambu ) :: I , U associate ( R => this % secondorder , Q => this % spinmixing , M0 => this % M0 ) U = M0 * G0 * M0 I = ( 0.25 * R * Q ) * ( U * G0 - G0 * U ) end associate end function pure function spinactive_current2_crossterms () result ( I ) !! Calculate the 2nd-order cross-terms in the matrix current. type ( nambu ) :: I , U associate ( R => this % secondorder , M0 => this % M0 ) U = S0 * G0 * M0 + M0 * G0 * S0 + S1 I = (( 0.00 , 0.25 ) * R ) * ( U * G0 - G0 * U ) end associate end function end function pure subroutine spinactive_kinetic_current ( this , G0 , G1 , C0 , C1 ) !! Calculate the kinetic boundary coefficients at an interface with spin-active properties. !! These can be used to calculate the generalized current according to J = C₀H₀ - C₁H₁. class ( spinactive ), intent ( in ) :: this type ( propagator ), intent ( in ) :: G0 !! Propagator (this  side) type ( propagator ), intent ( in ) :: G1 !! Propagator (other side) complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: C0 !! Boundary coefficient (this  side) complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: C1 !! Boundary coefficient (other side) type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR0 , GA0 type ( nambu ) :: GR1 , GA1 integer :: i , j ! Construct the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices (this side) GR0 = G0 % retarded () GA0 = G0 % advanced () ! Construct the propagator matrices (other side) GR1 = G1 % retarded () GA1 = G1 % advanced () ! Construct the boundary coefficients do j = 0 , 7 do i = 0 , 7 ! Calculate the boundary matrix coefficients C0 ( i , j ) = ( this % conductance / 8 ) * trace ( ( R ( GA1 ) * N ( i ) - N ( i ) * R ( GR1 ) ) * ( ( GR0 * N ( j ) - N ( j ) * GA0 ) ) ) C1 ( i , j ) = ( this % conductance / 8 ) * trace ( ( GA0 * N ( i ) - N ( i ) * GR0 ) * ( T ( GR1 * N ( j ) - N ( j ) * GA1 ) ) ) end do end do contains pure function T ( U ) ! Calculates the contents of the spin-active boundary condition commutators: !   I ~ [F(G₁), G₀] ! This is used for the calculation of the boundary coefficient matrices. ! Note that this version of the function only includes transmission terms, ! and used to evaluate contributions from the other side of the interface. type ( nambu ), intent ( in ) :: U type ( nambu ) :: T real ( wp ) :: GMR real ( wp ) :: GT1 associate ( M => this % M , P => this % polarization ) ! Calculate the normalized interface conductances GMR = P / ( 1 + sqrt ( 1 - P ** 2 )) GT1 = ( 1 - sqrt ( 1 - P ** 2 )) / ( 1 + sqrt ( 1 - P ** 2 )) ! Calculate the transmission function T = U + GMR * ( M * U + U * M ) + GT1 * M * U * M end associate end function pure function R ( U ) ! Calculates the contents of the spin-active boundary condition commutators: !   I ~ [F(G₁), G₀] ! This is used for the calculation of the boundary coefficient matrices. ! Note that this version of the function also includes reflection terms, ! and is used to evaluate contributions from this side of the interface. type ( nambu ), intent ( in ) :: U type ( nambu ) :: R complex ( wp ) :: Gphi associate ( M => this % M0 , Q => this % spinmixing ) ! Calculate the normalized interface conductance Gphi = ( 0 , - 1 ) * Q ! Calculate the reflection function R = T ( U ) + Gphi * M end associate end function end subroutine end module","tags":"","loc":"sourcefile/spinactive.f.html","title":"spinactive.f – ​"},{"text":"Contents Modules superconductor_m Source Code superconductor.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'superconductor', which models the physical state of a superconductor. The type is !> a member of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. module superconductor_m use :: stdio_m use :: condmat_m use :: conductor_m use :: ferromagnet_m private ! Type declaration type , public , extends ( ferromagnet ) :: superconductor ! These parameters control the physical characteristics of the material complex ( wp ), allocatable :: gap_history (:,:) !! Superconducting order parameter as a function of location (backup of previously calculated gaps on the location mesh) complex ( wp ), allocatable :: gap_function (:) !! Superconducting order parameter as a function of location (relative to the zero-temperature gap of a bulk superconductor) real ( wp ), allocatable :: gap_location (:) !! Location array for the gap function (required because we interpolate the gap to a higher resolution than the propagators) contains ! These methods define the class(material) interface procedure :: construct => superconductor_construct !! Construct  propagators procedure :: initialize => superconductor_initialize !! Initialize propagators ! These methods contain the equations that describe superconductors procedure :: diffusion_equation => superconductor_diffusion_equation !! Diffusion equation procedure :: kinetic_equation => superconductor_kinetic_equation !! Kinetic equation procedure :: update_gap => superconductor_update_gap !! Calculate the superconducting order parameter procedure :: update_boost => superconductor_update_boost !! Boost the convergence of the order parameter (Steffensen's method) procedure :: update_prehook => superconductor_update_prehook !! Update the internal variables before calculating the propagators procedure :: update_posthook => superconductor_update_posthook !! Update the superconducting order parameter from  the propagators ! These methods are used to access and mutate the parameters procedure :: gap => superconductor_gap !! Return the superconducting order parameter at a given position ! These methods define miscellaneous utility functions procedure :: conf => superconductor_conf !! Configure material parameters end type contains !--------------------------------------------------------------------------------! !                        IMPLEMENTATION OF CONSTRUCTORS                          ! !--------------------------------------------------------------------------------! impure subroutine superconductor_construct ( this ) !! Constructs a superconducting material that is initialized to a superconducting state. class ( superconductor ), intent ( inout ) :: this ! Call the superclass constructor call this % ferromagnet % construct ! Initialize superconductivity this % correlation = 1 ! Enable a higher-order solver this % method = 6 ! Allocate interpolation functions allocate ( this % gap_history ( size ( this % location ), 1 : 3 )) allocate ( this % gap_location ( 4096 * size ( this % location ))) allocate ( this % gap_function ( size ( this % gap_location ))) call linspace ( this % gap_location , this % location ( 1 ), this % location ( size ( this % location ))) end subroutine impure subroutine superconductor_initialize ( this ) !! Redefine the default initializer. class ( superconductor ), intent ( inout ) :: this integer :: info ! Call the superclass initializer call this % ferromagnet % initialize ! Disable status messages info = this % information if ( this % information >= 0 ) then this % information = - 1 end if ! Silently initialize the gap call this % update_gap ! Reenable status messages this % information = info ! Reset the iteration counter this % iteration = 0 end subroutine !--------------------------------------------------------------------------------! !                   IMPLEMENTATION OF SUPERCONDUCTOR METHODS                     ! !--------------------------------------------------------------------------------! pure subroutine superconductor_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. class ( superconductor ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p complex ( wp ) :: gap , gapt associate ( N => p % N , Nt => p % Nt , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Lookup the superconducting order parameter gap = ( this % gap ( z )) / ( this % thouless ) gapt = conjg ( gap ) ! Calculate the second derivatives of the Riccati parameters (superclass terms) call this % ferromagnet % diffusion_equation ( p , e , z ) ! Calculate the second derivatives of the Riccati parameters (superconductor terms) d2g = d2g - gap * pauli2 + gapt * g * pauli2 * g d2gt = d2gt + gapt * pauli2 - gap * gt * pauli2 * gt end associate end subroutine pure subroutine superconductor_kinetic_equation ( this , Gp , R , z ) !! Calculate the self-energies in the kinetic equation. class ( superconductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z complex ( wp ) :: gap , gapt type ( nambu ) :: S ! Call the superclass kinetic equation call this % ferromagnet % kinetic_equation ( Gp , R , z ) ! Lookup the superconducting order parameter gap = ( this % gap ( z )) / ( this % thouless ) gapt = conjg ( gap ) ! Construct the self-energy matrix S % matrix ( 1 , 4 ) = + gap S % matrix ( 2 , 3 ) = - gap S % matrix ( 3 , 2 ) = + gapt S % matrix ( 4 , 1 ) = - gapt ! Calculate the self-energy contribution R = R + Gp % selfenergy1 ( S ) end subroutine impure subroutine superconductor_update_prehook ( this ) !! Code to execute before running the update method of a class(superconductor) object. class ( superconductor ), intent ( inout ) :: this ! Call the superclass prehook call this % ferromagnet % update_prehook ! Modify the type string this % type_string = color_green // 'SUPERCONDUCTOR' // color_none end subroutine impure subroutine superconductor_update_posthook ( this ) !! Updates the superconducting order parameter based on the propagators of the system. class ( superconductor ), intent ( inout ) :: this ! Call the superclass posthook call this % ferromagnet % update_posthook ! Update the superconducting gap using fixpoint-iteration if ( this % selfconsistency >= 1 ) then call this % update_gap end if ! Boost the superconducting gap using Steffensen's method if ( this % selfconsistency >= 2 ) then call this % update_boost end if end subroutine impure subroutine superconductor_update_gap ( this ) !! Interpolate the superconducting correlations Δ(z) to a higher resolution, !! to make the calculations more stable near strong ferromagnetic materials. class ( superconductor ), intent ( inout ) :: this !! Superconductor object real ( wp ) :: diff !! Change between iterations ! Interpolate the gap as a function of position to a higher resolution this % gap_function = interpolate ( this % location , this % correlation , this % gap_location ) ! Save the calculated gap as backup associate ( b => this % gap_history , m => lbound ( this % gap_history , 2 ), n => ubound ( this % gap_history , 2 ) ) b (:, m : n - 1 ) = b (:, m + 1 : n ) b (:, n ) = this % correlation diff = mean ( abs ( b (:, n ) - b (:, n - 1 ))) end associate ! Status information if ( this % information >= 0 . and . this % order > 0 ) then write ( stdout , '(6x,a,f10.8,a,10x)' ) 'Gap change: ' , diff flush ( stdout ) end if end subroutine impure subroutine superconductor_update_boost ( this ) !! Boost the convergence of the order parameter using Steffensen's method. !! !! The basic idea is that a selfconsistent solution of the Usadel equations can be !! regarded as a fixpoint iteration problem Δ=f(Δ), where the function f consists !! of solving the diffusion and gap equations one time. We're seeking the point !! where f'(Δ)=0, and this can be done more efficiently using e.g. Newtons method !! than a straight-forward fixpoint-iteration. Using Newtons method, we get: !!   Δ_{n+1} = Δ_{n} - f'(Δ_n)/f''(Δ_n) !! Using a finite-difference approximation for the derivatives, we arrive at the !! Steffensen iteration scheme, which yields an improved 2nd-order convergence: !!   Δ_{n+3} = Δ_{n} - (Δ_{n+1} - Δ_{n})²/(Δ_{n+2} - 2Δ_{n+1} + Δ_{n}) !! In most of my tests, the simulation time is then reduced by a factor 2x to 5x. !! !! @NOTE: !!   I have also experimented with several higher-order methods, including methods !!   that utilize the 3rd derivative or perform multiple successive boosts. However, !!   my experience so far is that these are less stable than Steffensen's method, !!   and often converged more slowly. These methods have therefore been discarded. class ( superconductor ), intent ( inout ) :: this complex ( wp ), dimension ( size ( this % location )) :: g , d1 , d2 logical :: u ! Update the iterator this % iteration = modulo ( this % iteration + 1 , 8 ) ! Stop here if it is not yet time to boost if ( this % iteration > 0 ) then return end if ! Boost the convergence using Steffensen's method d1 = f ( 2 ) - f ( 1 ) d2 = f ( 3 ) - 2 * f ( 2 ) + f ( 1 ) g = f ( 1 ) - d1 ** 2 / d2 ! Do not boost adjacent to transparent interfaces if ( this % transparent_a ) then g ( lbound ( g , 1 )) = this % gap ( 0.0_wp ) end if if ( this % transparent_b ) then g ( ubound ( g , 1 )) = this % gap ( 1.0_wp ) end if ! Interpolate the gap as a function of position to a higher resolution this % gap_function = interpolate ( this % location , g , this % gap_location ) ! Perform one extra update if necessary u = . false . if ( associated ( this % material_a )) then u = u . or . ( this % material_a % order > 0 ) end if if ( associated ( this % material_b )) then u = u . or . ( this % material_b % order > 0 ) end if if ( u ) then call this % update ( bootstrap = . true .) end if ! Status information if ( this % information >= 0 . and . this % order > 0 ) then write ( stdout , '(6x,a,f10.8,a,10x)' ) 'Gap boost:  ' , mean ( abs ( g - f ( 3 ))) flush ( stdout ) end if contains pure function f ( n ) result ( r ) ! Define an accessor for the gap after n iterations. integer , intent ( in ) :: n complex ( wp ), dimension ( size ( this % gap_history , 1 )) :: r r = this % gap_history (:, n ) end function end subroutine !--------------------------------------------------------------------------------! !                    IMPLEMENTATION OF GETTERS AND SETTERS                       ! !--------------------------------------------------------------------------------! pure function superconductor_gap ( this , location ) result ( gap ) !! Returns the superconducting order parameter at the given location. class ( superconductor ), intent ( in ) :: this real ( wp ), intent ( in ) :: location complex ( wp ) :: gap integer :: n , m associate ( f => this % gap_function , fp => gap , p => location ) ! Calculate the index corresponding to the given location m = size ( f ) - 1 n = floor ( p * m + 1 ) ! Interpolate the superconducting order parameter at that point if ( n <= 1 ) then fp = f ( 1 ) else fp = f ( n - 1 ) + ( f ( n ) - f ( n - 1 )) * ( p * m - ( n - 2 )) end if end associate end function !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! impure subroutine superconductor_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( superconductor ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val select case ( key ) case default call this % ferromagnet % conf ( key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/superconductor.f.html","title":"superconductor.f – ​"},{"text":"Contents Modules ferromagnet_m Source Code ferromagnet.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'ferromagnet', which models the physical state of a ferromagnet. The type is a !> member of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. module ferromagnet_m use :: stdio_m use :: condmat_m use :: conductor_m private ! Type declaration type , public , extends ( conductor ) :: ferromagnet real ( wp ), allocatable :: zeeman !! How easy the material is magnetized by spin accumulation real ( wp ), allocatable :: exchange (:,:) !! Magnetic exchange field as a function of position real ( wp ), allocatable , private :: z (:) !! Used by internal subroutines to handle location data type ( spin ), allocatable , private :: h (:) !! Used by internal subroutines to handle exchange fields contains ! These methods define the class(material) interface procedure :: update_prehook => ferromagnet_update_prehook !! Code to execute before calculating the propagators ! These methods contain the equations that describe ferromagnets procedure :: diffusion_equation => ferromagnet_diffusion_equation !! Diffusion equation procedure :: kinetic_equation => ferromagnet_kinetic_equation !! Kinetic equation ! These methods define miscellaneous utility functions procedure :: conf => ferromagnet_conf !! Configures material parameters end type contains !--------------------------------------------------------------------------------! !                    IMPLEMENTATION OF FERROMAGNET METHODS                       ! !--------------------------------------------------------------------------------! pure subroutine ferromagnet_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. class ( ferromagnet ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p type ( spin ) :: h , ht real ( wp ) :: d integer :: n , m associate ( g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Calculate the second derivatives of the Riccati parameters (conductor terms) call this % conductor % diffusion_equation ( p , e , z ) if ( allocated ( this % h )) then ! Calculate the index corresponding to the given location m = size ( this % h ) - 1 ! Number of array intervals n = floor ( z * m + 1 ) ! Nearest position in array ! Extract the exchange field terms at that point if ( n <= 1 ) then ! Left edge of the material h = this % h ( 1 ) else ! Linear interpolation from known values. The relative displacement d is defined ! as [z - location(n-1)]/[location(n) - location(n-1)], but assuming location(:) ! is a uniform array of values in the range [0,1], the below will be equivalent. d = z * m - ( n - 2 ) h = this % h ( n - 1 ) + ( this % h ( n ) - this % h ( n - 1 )) * d end if ! Find the corresponding tilde-conjugate ht = conjg ( h ) ! Calculate the second derivatives of the Riccati parameters (ferromagnet terms) associate ( i => ( 0.00_wp , 1.00_wp ) ) d2g = d2g - i * ( h * g - g * ht ) d2gt = d2gt + i * ( ht * gt - gt * h ) end associate end if end associate end subroutine pure subroutine ferromagnet_kinetic_equation ( this , Gp , R , z ) !! Calculate the self-energies in the kinetic equation. class ( ferromagnet ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z type ( nambu ) :: S real ( wp ) :: d type ( spin ) :: h , ht integer :: n , m ! Call the superclass kinetic equation call this % conductor % kinetic_equation ( Gp , R , z ) if ( allocated ( this % h )) then ! Calculate the index corresponding to the given location m = size ( this % h ) - 1 ! Number of array intervals n = floor ( z * m + 1 ) ! Nearest position in array ! Extract the exchange field terms at that point if ( n <= 1 ) then ! Left edge of the material h = this % h ( 1 ) else ! Linear interpolation from known values. The relative displacement d is defined ! as [z - location(n-1)]/[location(n) - location(n-1)], but assuming location(:) ! is a uniform array of values in the range [0,1], the below will be equivalent. d = z * m - ( n - 2 ) h = this % h ( n - 1 ) + ( this % h ( n ) - this % h ( n - 1 )) * d end if ! Find the corresponding tilde-conjugate ht = conjg ( h ) ! Construct the self-energy matrix S % matrix ( 1 : 2 , 1 : 2 ) = h S % matrix ( 3 : 4 , 3 : 4 ) = ht ! Calculate the self-energy contribution R = R + Gp % selfenergy1 ( S ) end if end subroutine impure subroutine ferromagnet_update_prehook ( this ) !! Updates the exchange field terms in the diffusion equation. class ( ferromagnet ), intent ( inout ) :: this ! Ferromagnet object that will be updated real ( wp ), allocatable , dimension (:,:) :: interpolation ! High-resolution magnetization interpolation integer :: n ! Loop variable ! Call the superclass prehook call this % conductor % update_prehook ! Update magnetization matrices if ( allocated ( this % exchange ) . or . allocated ( this % zeeman )) then ! Allocate and initialize workspace allocate ( interpolation ( 3 , size ( this % location ) * 4096 )) if (. not . allocated ( this % h )) then allocate ( this % h ( size ( interpolation , 2 ))) allocate ( this % z ( size ( interpolation , 2 ))) call linspace ( this % z , this % location ( 1 ), this % location ( size ( this % location ))) end if ! Calculate the effective magnetization this % magnetization = 0 if ( allocated ( this % exchange )) then this % magnetization = this % magnetization + ( this % exchange ( 1 : 3 ,:)) end if if ( allocated ( this % zeeman )) then this % magnetization = this % magnetization + ( this % accumulation ( 1 : 3 ,:)) * ( this % zeeman ) end if ! High-resolution interpolation interpolation ( 1 ,:) = interpolate ( this % location , this % magnetization ( 1 ,:), this % z ) interpolation ( 2 ,:) = interpolate ( this % location , this % magnetization ( 2 ,:), this % z ) interpolation ( 3 ,:) = interpolate ( this % location , this % magnetization ( 3 ,:), this % z ) ! Update the internal variables do n = 1 , size ( interpolation , 2 ) this % h ( n ) = ( interpolation ( 1 , n ) * pauli1 + interpolation ( 2 , n ) * pauli2 + interpolation ( 3 , n ) * pauli3 ) / ( this % thouless ) end do ! Clean up deallocate ( interpolation ) end if ! Modify the type string if ( allocated ( this % exchange ) . or . allocated ( this % zeeman )) then this % type_string = color_red // 'MAGNET' // color_none end if end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! impure subroutine ferromagnet_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( ferromagnet ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val select case ( key ) case ( 'magnetization' ) call evaluate ( val , this % location , this % exchange ) case ( 'zeeman' ) allocate ( this % zeeman ) call evaluate ( val , this % zeeman ) case default ! Pass this option to the superclass call this % conductor % conf ( key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/ferromagnet.f.html","title":"ferromagnet.f – ​"},{"text":"Contents Modules halfmetal_m Source Code halfmetal.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'halfmetal', which models the physical state of a strong or halfmetallic ferromagnet. !> The type is a member of class(conductor), and inherits the internal structure and generic methods defined there. !> !> @TODO !>   Add an update_posthook to rescale density(:) and current(:) with the dependence of the diffusion constant matrix !>   on the polarization. Remember to check how the polarization dependence varies with the number of dimensions. !> !> @TODO !>   Check if a non-linear dependence of the polarization matrix on the polarization is more sensible? module halfmetal_m use :: stdio_m use :: condmat_m use :: material_m use :: conductor_m private ! Type declarations type , public , extends ( conductor ) :: halfmetal real ( wp ) :: polarization = 0.0_wp !! Spin-polarization of the ferromagnet type ( spin ), private :: P !! Polarization matrix contains procedure :: conf => halfmetal_conf !! Configures the material parameters procedure :: diffusion_equation => halfmetal_diffusion_equation !! Defines the Usadel diffusion equation procedure :: diffusion_equation_a => halfmetal_diffusion_equation_a !! Boundary condition at the left  interface procedure :: diffusion_equation_b => halfmetal_diffusion_equation_b !! Boundary condition at the right interface procedure :: update_prehook => halfmetal_update_prehook !! Code to execute before calculating the propagators procedure :: update_posthook => halfmetal_update_posthook !! Code to execute after  calculating the propagators procedure :: update_density => halfmetal_update_density !! Calculates the density of states end type contains !--------------------------------------------------------------------------------! !                     IMPLEMENTATION OF HALFMETAL EQUATIONS                      ! !--------------------------------------------------------------------------------! pure subroutine halfmetal_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second-derivatives !! of the Riccati parameters at an energy e and a position z. class ( halfmetal ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p type ( spin ) :: h , ht , dh , dht type ( spin ) :: N , Nt associate ( g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Ensure that the Riccati parameters are diagonal h = g % matrix * pauli0 % matrix ht = gt % matrix * pauli0 % matrix dh = dg % matrix * pauli0 % matrix dht = dgt % matrix * pauli0 % matrix ! Calculate the normalization matrices N = inverse ( pauli0 - h * ht ) Nt = inverse ( pauli0 - ht * h ) ! Calculate the second-derivatives of the Riccati parameters associate ( P => this % P ) d2g = ( - 2.0_wp , 0.0_wp ) * dh * Nt * ht * dh - ( 0.0_wp , 2.0_wp ) * e * P * h d2gt = ( - 2.0_wp , 0.0_wp ) * dht * N * h * dht - ( 0.0_wp , 2.0_wp ) * e * P * ht end associate end associate end subroutine pure subroutine halfmetal_diffusion_equation_a ( this , p , a , r , rt ) !! Calculate residuals from the boundary conditions at the left interface. class ( halfmetal ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , a type ( spin ), intent ( inout ) :: r , rt ! Diagonal components: use regular spin-active boundary conditions call this % conductor % diffusion_equation_a ( p , a , r , rt ) ! Off-diagonal components: use boundary conditions g,gt=0 r % matrix ( 1 , 2 ) = p % g % matrix ( 1 , 2 ) r % matrix ( 2 , 1 ) = p % g % matrix ( 2 , 1 ) rt % matrix ( 1 , 2 ) = p % gt % matrix ( 1 , 2 ) rt % matrix ( 2 , 1 ) = p % gt % matrix ( 2 , 1 ) end subroutine pure subroutine halfmetal_diffusion_equation_b ( this , p , b , r , rt ) !! Calculate residuals from the boundary conditions at the right interface. class ( halfmetal ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , b type ( spin ), intent ( inout ) :: r , rt ! Diagonal components: use regular spin-active boundary conditions call this % conductor % diffusion_equation_b ( p , b , r , rt ) ! Off-diagonal components: use boundary conditions g,gt=0 r % matrix ( 1 , 2 ) = p % g % matrix ( 1 , 2 ) r % matrix ( 2 , 1 ) = p % g % matrix ( 2 , 1 ) rt % matrix ( 1 , 2 ) = p % gt % matrix ( 1 , 2 ) rt % matrix ( 2 , 1 ) = p % gt % matrix ( 2 , 1 ) end subroutine impure subroutine halfmetal_update_prehook ( this ) !! Code to execute before running the update method of a class(halfmetal) object. class ( halfmetal ), intent ( inout ) :: this ! Verify that a polarization is defined if ( abs ( this % polarization ) < eps ) then call error ( 'Tried to update a halfmetal with no defined polarization!' ) end if ! Update the polarization matrix this % P % matrix ( 1 , 1 ) = 2 / ( 1 + eps + this % polarization ) this % P % matrix ( 1 , 2 ) = 0 this % P % matrix ( 2 , 1 ) = 0 this % P % matrix ( 2 , 2 ) = 2 / ( 1 + eps - this % polarization ) ! Update the left  interface parameters this % spinactive_a % magnetization = [ 0 , 0 , 1 ] this % spinactive_a % polarization = this % polarization ! Update the right interface parameters this % spinactive_b % magnetization = [ 0 , 0 , 1 ] this % spinactive_b % polarization = this % polarization ! Call the superclass prehook call this % conductor % update_prehook ! Modify the type string this % type_string = color_red // 'HALFMETAL' // color_none end subroutine impure subroutine halfmetal_update_posthook ( this ) !! Code to execute after running the update method of a class(halfmetal) object. class ( halfmetal ), intent ( inout ) :: this real ( wp ) :: error integer :: n , m ! Call the superclass posthook call this % conductor % update_posthook ! Perform sanity checks error = 0 do m = 1 , size ( this % location ) do n = 1 , size ( this % energy ) ! Find the maximum off-diagonal element error = max ( abs ( this % propagator ( n , m )% g % matrix ( 1 , 2 )), error ) error = max ( abs ( this % propagator ( n , m )% g % matrix ( 2 , 1 )), error ) error = max ( abs ( this % propagator ( n , m )% gt % matrix ( 1 , 2 )), error ) error = max ( abs ( this % propagator ( n , m )% gt % matrix ( 2 , 1 )), error ) end do end do ! Update density of states call this % update_density ! Status information if ( this % information >= 0 . and . this % order > 0 ) then write ( stdout , '(6x,a,f10.8,a)' ) 'Max error:  ' , error , '                                        ' flush ( stdout ) end if end subroutine pure subroutine halfmetal_update_density ( this ) !! Calculate the density of states in the halfmetal. class ( halfmetal ), intent ( inout ) :: this integer :: n , m ! Allocate memory if necessary if (. not . allocated ( this % density )) then allocate ( this % density ( size ( this % energy ), size ( this % location ), 0 : 7 )) end if ! Placeholder code this % density = inf ! ! Calculate the density of states at each position and energy ! ! TODO: Generalize this to work for strong ferromagnets too. ! if (this % polarization > 0) then !   do m=1,size(this%location) !     do n=1,size(this%energy) !       this % density(n,m) = 2 * re(this % propagator(n,m) % N % matrix(1,1)) - 1 !     end do !   end do ! else !   do m=1,size(this%location) !     do n=1,size(this%energy) !       this % density(n,m) = 2 * re(this % propagator(n,m) % N % matrix(2,2)) - 1 !     end do !   end do ! end if end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! impure subroutine halfmetal_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( halfmetal ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val real ( wp ) :: tmp select case ( key ) case ( 'polarization' ) call evaluate ( val , this % polarization ) case default call this % conductor % conf ( key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/halfmetal.f.html","title":"halfmetal.f – ​"},{"text":"Contents Modules conductor_m Source Code conductor.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'conductor', which models the physical state of a conductor for a discretized range !> of positions and energies.  It has two main applications: (i) it can be used as a base type for more exotic materials, !> such as superconductors and ferromagnets; (ii) it can be used in conjunction with such materials in hybrid structures. module conductor_m use :: stdio_m use :: condmat_m use :: material_m use :: spinorbit_m use :: spinactive_m use :: spinscattering_m private ! Type declarations type , public , extends ( material ) :: conductor ! Physical fields in the material type ( spinscattering ), allocatable :: spinscattering !! Spin-dependent scattering type ( spinorbit ), allocatable :: spinorbit !! Spin-orbit coupling ! Physical fields at the interfaces type ( spinactive ), allocatable :: spinactive_a !! Spin-active interface (left) type ( spinactive ), allocatable :: spinactive_b !! Spin-active interface (right) contains ! These methods are required by the class(material) abstract interface procedure :: construct => conductor_construct !! Constructs the object procedure :: initialize => conductor_initialize !! Initializes propagators procedure :: update_prehook => conductor_update_prehook !! Code to execute before updates procedure :: update_posthook => conductor_update_posthook !! Code to execute after  updates ! These methods contain the equations that describe electrical conductors procedure :: diffusion_equation => conductor_diffusion_equation !! Diffusion equation procedure :: diffusion_equation_a => conductor_diffusion_equation_a !! Boundary condition (left) procedure :: diffusion_equation_b => conductor_diffusion_equation_b !! Boundary condition (right) procedure :: kinetic_equation => conductor_kinetic_equation !! Kinetic equation procedure :: kinetic_equation_a => conductor_kinetic_equation_a !! Boundary condition (left) procedure :: kinetic_equation_b => conductor_kinetic_equation_b !! Boundary condition (right) ! These methods define miscellaneous utility functions procedure :: conf => conductor_conf !! Configures material parameters end type contains !--------------------------------------------------------------------------------! !                        IMPLEMENTATION OF CONSTRUCTORS                          ! !--------------------------------------------------------------------------------! impure subroutine conductor_construct ( this ) !! Constructs a conductor object initialized to a superconducting state. class ( conductor ), intent ( inout ) :: this ! Initialize locations allocate ( this % location ( 101 )) call linspace ( this % location , 0 + 1 e - 10_wp , 1 - 1 e - 10_wp ) ! Initialize energies allocate ( this % energy ( 1000 )) call linspace ( this % energy ( : 800 ), 1 e - 6_wp , 4.00_wp ) call linspace ( this % energy ( 800 : ), 4.00_wp , 3 0.0_wp ) ! Allocate memory for propagators allocate ( this % propagator ( size ( this % energy ), size ( this % location ))) ! Initialize superconductivity allocate ( this % correlation ( size ( this % location ))) this % correlation = eps ! Initialize magnetism allocate ( this % magnetization ( 1 : 3 , size ( this % location ))) this % magnetization = 0 ! Allocate memory for physical observables allocate ( this % supercurrent ( 0 : 7 , size ( this % location ))) allocate ( this % lossycurrent ( 0 : 7 , size ( this % location ))) allocate ( this % accumulation ( 0 : 7 , size ( this % location ))) allocate ( this % density ( size ( this % energy ), size ( this % location ), 0 : 7 )) ! Initialize observables this % supercurrent = 0 this % lossycurrent = 0 this % accumulation = 0 this % density = 0 ! Allocate boundary condition objects allocate ( this % spinactive_a ) allocate ( this % spinactive_b ) end subroutine impure subroutine conductor_initialize ( this ) !! Define the default initializer. class ( conductor ), intent ( inout ) :: this integer :: n , m ! Initialize the Riccati parameters do m = 1 , size ( this % location ) do n = 1 , size ( this % energy ) this % propagator ( n , m ) = propagator ( cx ( this % energy ( n ), this % scattering ), this % correlation ( m ) ) end do end do ! Initialize the distribution function do m = 1 , size ( this % location ) do n = 1 , size ( this % energy ) ! Finite nonequilibrium potentials this % propagator ( n , m ) % h = & [ & ( f ( n , + 1 , + 1 ) + f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )) * u ( 1 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )) * u ( 2 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )) * u ( 3 ), & ( f ( n , + 1 , + 1 ) + f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )) * u ( 1 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )) * u ( 2 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )) * u ( 3 ) & ] ! Transverse applied potentials if ( this % transverse ) then this % propagator ( n , m ) % h ( 4 : 7 ) = 0 end if ! Derivatives of the above this % propagator ( n , m ) % dh = 0 this % propagator ( n , m ) % d2h = 0 end do end do contains pure function f ( n , c , s ) result ( h ) ! Fermi distribution for a given energy (n), charge parity (c=±1), and spin (s=±1). integer , intent ( in ) :: n , c , s real ( wp ) :: h associate ( E => this % energy ( n ), & V => this % voltage * c , & Vs => this % spinvoltage * c * s , & T => this % temperature , & Ts => this % spintemperature * s ) h = tanh ( 0.8819384944310228_wp * ( E + V + Vs ) / ( T + Ts )) / 4 end associate end function pure function u ( m ) result ( r ) ! Nonequilibrium spin-projection along the m'th basis vector. integer , intent ( in ) :: m real ( wp ) :: r r = this % spinaxis ( m ) end function end subroutine !--------------------------------------------------------------------------------! !                     IMPLEMENTATION OF CONDUCTOR EQUATIONS                      ! !--------------------------------------------------------------------------------! pure subroutine conductor_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second-derivatives !! of the Riccati parameters at an energy e and position z. class ( conductor ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p associate ( N => p % N , Nt => p % Nt , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Calculate the second-derivatives of the Riccati parameters d2g = ( - 2.0_wp , 0.0_wp ) * dg * Nt * gt * dg - ( 0.0_wp , 2.0_wp ) * e * g d2gt = ( - 2.0_wp , 0.0_wp ) * dgt * N * g * dgt - ( 0.0_wp , 2.0_wp ) * e * gt ! Calculate the contribution from a spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % diffusion_equation ( p ) end if ! Calculate the contribution from spin-dependent scattering if ( allocated ( this % spinscattering )) then call this % spinscattering % diffusion_equation ( p ) end if end associate end subroutine pure subroutine conductor_diffusion_equation_a ( this , p , a , r , rt ) !! Calculate residuals from the boundary conditions at the left interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , a type ( spin ), intent ( inout ) :: r , rt complex ( wp ), dimension ( 1 : 4 , 1 : 4 ) :: I ! Calculate a matrix current from the propagators I = ( + 0.50_wp ) * this % spinactive_a % diffusion_current ( p % retarded (), a % retarded ()) ! Calculate the deviation from the boundary condition associate ( g => p % g , gt => p % gt , dg => p % dg , dgt => p % dgt ) r = dg - ( pauli0 - g * gt ) * ( I ( 1 : 2 , 3 : 4 ) - I ( 1 : 2 , 1 : 2 ) * g ) rt = dgt - ( pauli0 - gt * g ) * ( I ( 3 : 4 , 1 : 2 ) - I ( 3 : 4 , 3 : 4 ) * gt ) end associate ! Gauge-dependent terms in the case of spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % diffusion_equation_a ( p , r , rt ) end if end subroutine pure subroutine conductor_diffusion_equation_b ( this , p , b , r , rt ) !! Calculate residuals from the boundary conditions at the right interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , b type ( spin ), intent ( inout ) :: r , rt complex ( wp ), dimension ( 1 : 4 , 1 : 4 ) :: I ! Calculate a matrix current from the propagators I = ( - 0.50_wp ) * this % spinactive_b % diffusion_current ( p % retarded (), b % retarded ()) ! Calculate the deviation from the boundary condition associate ( g => p % g , gt => p % gt , dg => p % dg , dgt => p % dgt ) r = dg - ( pauli0 - g * gt ) * ( I ( 1 : 2 , 3 : 4 ) - I ( 1 : 2 , 1 : 2 ) * g ) rt = dgt - ( pauli0 - gt * g ) * ( I ( 3 : 4 , 1 : 2 ) - I ( 3 : 4 , 3 : 4 ) * gt ) end associate ! Gauge-dependent terms in the case of spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % diffusion_equation_b ( p , r , rt ) end if end subroutine pure subroutine conductor_kinetic_equation ( this , Gp , R , z ) !! Calculate the self-energies in the kinetic equation. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z ! There are no normal-metal terms R = 0 ! Spin-dependent scattering terms if ( allocated ( this % spinscattering )) then call this % spinscattering % kinetic_equation ( Gp , R ) end if end subroutine pure subroutine conductor_kinetic_equation_a ( this , Gp , Ga , Cp , Ca ) !! Calculate proportionality matrices for the boundary conditions at the left interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Ga complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Ca ! Calculate the boundary coefficients call this % spinactive_a % kinetic_current ( Gp , Ga , Cp , Ca ) ! Direction of the interface normal Cp = + Cp Ca = + Ca end subroutine pure subroutine conductor_kinetic_equation_b ( this , Gp , Gb , Cp , Cb ) !! Calculate proportionality matrices for the boundary conditions at the right interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Gb complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Cb ! Calculate the boundary coefficients call this % spinactive_b % kinetic_current ( Gp , Gb , Cp , Cb ) ! Direction of the interface normal Cp = - Cp Cb = - Cb end subroutine impure subroutine conductor_update_prehook ( this ) !! Code to execute before running the update method of a class(conductor) object. class ( conductor ), intent ( inout ) :: this ! Discard the tunneling conductance at vacuum interfaces if (. not . associated ( this % material_a )) then this % spinactive_a % conductance = 1 end if if (. not . associated ( this % material_b )) then this % spinactive_b % conductance = 1 end if ! Prepare variables associated with spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % update_prehook end if ! Prepare variables associated with spin-active interfaces call this % spinactive_a % update_prehook call this % spinactive_b % update_prehook ! Modify the type string this % type_string = color_yellow // 'CONDUCTOR' // color_none end subroutine impure subroutine conductor_update_posthook ( this ) !! Code to execute after running the update method of a class(conductor) object. !! In particular, this function calculates supercurrents, dissipative currents, !! accumulations, and density of states, and stores the results in the object. class ( conductor ), intent ( inout ) :: this type ( nambu ), allocatable :: gauge real ( wp ), allocatable , dimension (:,:) :: I , J , Q complex ( wp ), allocatable , dimension (:) :: S integer :: n , m , k ! Allocate memory for the workspace allocate ( S ( size ( this % energy ))) allocate ( I ( size ( this % energy ), 0 : 7 )) allocate ( J ( size ( this % energy ), 0 : 7 )) allocate ( Q ( size ( this % energy ), 0 : 7 )) ! Calculate the gauge contribution if ( allocated ( this % spinorbit )) then allocate ( gauge ) gauge = diag ( + this % spinorbit % Az % matrix ,& - this % spinorbit % Azt % matrix ) end if ! Simplify the namespace associate ( E => this % energy , & z => this % location , & G => this % propagator , & D => this % density ) ! Iterate over positions do n = 1 , size ( z ) ! Calculate the spectral properties at this position do m = 1 , size ( E ) S ( m ) = G ( m , n ) % correlation () Q ( m ,:) = G ( m , n ) % accumulation () I ( m ,:) = G ( m , n ) % supercurrent ( gauge ) J ( m ,:) = G ( m , n ) % lossycurrent ( gauge ) D ( m , n ,:) = G ( m , n ) % density () end do ! Superconducting correlations depend on the cutoff S = S / log ( 2 * E ( size ( E ))) ! Heat and spin-heat observables depend on the energy do k = 4 , 7 Q (:, k ) = E * Q (:, k ) I (:, k ) = E * I (:, k ) J (:, k ) = E * J (:, k ) end do ! Integrate the spectral observables to find the total observables this % correlation ( n ) = integrate ( E , S , E ( 1 ), E ( size ( E ))) do k = 0 , 7 this % accumulation ( k , n ) = integrate ( E , Q (:, k ), E ( 1 ), E ( size ( E ))) this % supercurrent ( k , n ) = integrate ( E , I (:, k ), E ( 1 ), E ( size ( E ))) this % lossycurrent ( k , n ) = integrate ( E , J (:, k ), E ( 1 ), E ( size ( E ))) end do end do end associate ! Reset the center-of-mass phase if ( this % phaselock ) then associate ( g => this % correlation , i => ( 0 , 1 )) g = g / exp ( i * arg ( mean ( g ))) end associate end if ! Deallocate workspace memory deallocate ( S , Q , I , J ) end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! impure subroutine conductor_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( conductor ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val real ( wp ) :: tmp select case ( key ) case ( 'conductance_a' ) call evaluate ( val , this % spinactive_a % conductance ) case ( 'conductance_b' ) call evaluate ( val , this % spinactive_b % conductance ) case ( 'resistance_a' ) call evaluate ( val , tmp ) this % spinactive_a % conductance = 1 / tmp case ( 'resistance_b' ) call evaluate ( val , tmp ) this % spinactive_b % conductance = 1 / tmp case ( 'spinmixing_a' ) call evaluate ( val , this % spinactive_a % spinmixing ) case ( 'spinmixing_b' ) call evaluate ( val , this % spinactive_b % spinmixing ) case ( 'secondorder_a' ) call evaluate ( val , this % spinactive_a % secondorder ) case ( 'secondorder_b' ) call evaluate ( val , this % spinactive_b % secondorder ) case ( 'polarization_a' ) call evaluate ( val , this % spinactive_a % polarization ) case ( 'polarization_b' ) call evaluate ( val , this % spinactive_b % polarization ) case ( 'magnetization_a' ) call evaluate ( val , this % spinactive_a % magnetization ) this % spinactive_a % magnetization = unitvector ( this % spinactive_a % magnetization ) case ( 'magnetization_b' ) call evaluate ( val , this % spinactive_b % magnetization ) this % spinactive_b % magnetization = unitvector ( this % spinactive_b % magnetization ) case ( 'misalignment0_a' ) call evaluate ( val , this % spinactive_a % misalignment0 ) this % spinactive_a % misalignment0 = unitvector ( this % spinactive_a % misalignment0 ) case ( 'misalignment0_b' ) call evaluate ( val , this % spinactive_b % misalignment0 ) this % spinactive_b % misalignment0 = unitvector ( this % spinactive_b % misalignment0 ) case ( 'misalignment1_a' ) call evaluate ( val , this % spinactive_a % misalignment1 ) this % spinactive_a % misalignment1 = unitvector ( this % spinactive_a % misalignment1 ) case ( 'misalignment1_b' ) call evaluate ( val , this % spinactive_b % misalignment1 ) this % spinactive_b % misalignment1 = unitvector ( this % spinactive_b % misalignment1 ) case ( 'nanowire' ) call evaluate ( val , tmp ) if (. not . allocated ( this % spinorbit )) then allocate ( this % spinorbit ) this % spinorbit = spinorbit ( this ) end if this % spinorbit % field ( 3 ) = this % spinorbit % field ( 3 ) + ( - tmp ) * pauli1 case ( 'rashba' ) call evaluate ( val , tmp ) if (. not . allocated ( this % spinorbit )) then allocate ( this % spinorbit ) this % spinorbit = spinorbit ( this ) end if this % spinorbit % field ( 1 ) = this % spinorbit % field ( 1 ) + ( - tmp ) * pauli2 this % spinorbit % field ( 2 ) = this % spinorbit % field ( 2 ) + ( + tmp ) * pauli1 case ( 'dresselhaus' ) call evaluate ( val , tmp ) if (. not . allocated ( this % spinorbit )) then allocate ( this % spinorbit ) this % spinorbit = spinorbit ( this ) end if this % spinorbit % field ( 1 ) = this % spinorbit % field ( 1 ) + ( + tmp ) * pauli1 this % spinorbit % field ( 2 ) = this % spinorbit % field ( 2 ) + ( - tmp ) * pauli2 case ( 'gap' ) block real ( wp ), allocatable , dimension (:) :: r associate ( g => this % correlation , z => this % location , i => ( 0 , 1 )) call evaluate ( val , z , r ) g = r * exp ( i * arg ( g )) end associate end block case ( 'phase' ) block real ( wp ), allocatable , dimension (:) :: r associate ( g => this % correlation , z => this % location , i => ( 0 , 1 )) call evaluate ( val , z , r ) g = abs ( g ) * exp ( i * pi * r ) end associate end block case ( 'scattering_spinflip' ) if (. not . allocated ( this % spinscattering )) then allocate ( this % spinscattering ) this % spinscattering = spinscattering ( this ) end if call evaluate ( val , this % spinscattering % spinflip ) case ( 'scattering_spinorbit' ) if (. not . allocated ( this % spinscattering )) then allocate ( this % spinscattering ) this % spinscattering = spinscattering ( this ) end if call evaluate ( val , this % spinscattering % spinorbit ) case ( 'depairing' ) if (. not . allocated ( this % spinscattering )) then allocate ( this % spinscattering ) this % spinscattering = spinscattering ( this ) end if call evaluate ( val , this % spinscattering % depairing ) case ( 'zeroenergy' ) block logical :: tmp call evaluate ( val , tmp ) if ( tmp ) then deallocate ( this % energy ) allocate ( this % energy ( 1 )) this % energy ( 1 ) = 0 end if end block case default call material_conf ( this , key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/conductor.f.html","title":"conductor.f – ​"},{"text":"Contents Modules spinorbit_m Source Code spinorbit.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This submodule is included by conductor.f, and contains the equations which model spin-orbit coupling in diffusive materials. module spinorbit_m use :: condmat_m use :: material_m private ! Public interface public spinorbit , spinorbit_construct ! Type declarations type :: spinorbit class ( material ), pointer :: material => null () !! Pointer to the material modelled by this instance type ( spin ), dimension ( 1 : 3 ) :: field !! Spin-orbit coupling field (SU(2) gauge field) type ( spin ) :: Ax , Ay , Az , A2 !! Spin-orbit coupling matrices (the components and square) type ( spin ) :: Axt , Ayt , Azt , A2t !! Spin-orbit coupling matrices (tilde-conjugated versions) contains procedure :: diffusion_equation => spinorbit_diffusion_equation !! Diffusion equation procedure :: diffusion_equation_a => spinorbit_diffusion_equation_a !! Boundary condition (left) procedure :: diffusion_equation_b => spinorbit_diffusion_equation_b !! Boundary condition (right) procedure :: update_prehook => spinorbit_update_prehook !! Code to execute before updates end type ! Type constructors interface spinorbit module procedure spinorbit_construct end interface contains function spinorbit_construct ( parent ) result ( this ) !! Constructs a spinorbit object with a given parent material. type ( spinorbit ) :: this class ( material ), target :: parent ! Save a pointer to the parent object this % material => parent ! Ensure that the spin-orbit field is zero this % field = spin ( 0 ) end function impure subroutine spinorbit_update_prehook ( this ) !! Updates the internal variables associated with spin-orbit coupling. class ( spinorbit ), intent ( inout ) :: this ! Spin-orbit coupling terms in the equations for the Riccati parameter γ this % Ax = this % material % length * this % field ( 1 ) this % Ay = this % material % length * this % field ( 2 ) this % Az = this % material % length * this % field ( 3 ) this % A2 = this % Ax ** 2 + this % Ay ** 2 + this % Az ** 2 ! Spin-orbit coupling terms in the equations for the Riccati parameter γ~ this % Axt = conjg ( this % Ax ) this % Ayt = conjg ( this % Ay ) this % Azt = conjg ( this % Az ) this % A2t = conjg ( this % A2 ) end subroutine pure subroutine spinorbit_diffusion_equation ( this , p ) !! Calculate the spin-orbit coupling terms in the diffusion equation, !! and update the second derivatives of the Riccati parameters. class ( spinorbit ), intent ( in ) :: this type ( propagator ), intent ( inout ) :: p associate ( Ax => this % Ax , Axt => this % Axt , & Ay => this % Ay , Ayt => this % Ayt , & Az => this % Az , Azt => this % Azt , & A2 => this % A2 , A2t => this % A2t , & N => p % N , Nt => p % Nt , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Update the second derivatives of the Riccati parameters d2g = d2g + ( A2 * g - g * A2t ) & + ( 2.0_wp , 0.0_wp ) * ( Ax * g + g * Axt ) * Nt * ( Axt + gt * Ax * g ) & + ( 2.0_wp , 0.0_wp ) * ( Ay * g + g * Ayt ) * Nt * ( Ayt + gt * Ay * g ) & + ( 2.0_wp , 0.0_wp ) * ( Az * g + g * Azt ) * Nt * ( Azt + gt * Az * g ) & + ( 0.0_wp , 2.0_wp ) * ( Az + g * Azt * gt ) * N * dg & + ( 0.0_wp , 2.0_wp ) * dg * Nt * ( gt * Az * g + Azt ) d2gt = d2gt + ( A2t * gt - gt * A2 ) & + ( 2.0_wp , 0.0_wp ) * ( Axt * gt + gt * Ax ) * N * ( Ax + g * Axt * gt ) & + ( 2.0_wp , 0.0_wp ) * ( Ayt * gt + gt * Ay ) * N * ( Ay + g * Ayt * gt ) & + ( 2.0_wp , 0.0_wp ) * ( Azt * gt + gt * Az ) * N * ( Az + g * Azt * gt ) & - ( 0.0_wp , 2.0_wp ) * ( Azt + gt * Az * g ) * Nt * dgt & - ( 0.0_wp , 2.0_wp ) * dgt * N * ( g * Azt * gt + Az ) end associate end subroutine pure subroutine spinorbit_diffusion_equation_a ( this , p , r , rt ) !! Calculate the spin-orbit coupling terms in the left boundary condition, and update the residuals. class ( spinorbit ), target , intent ( in ) :: this type ( propagator ), intent ( in ) :: p type ( spin ), intent ( inout ) :: r , rt associate ( Az => this % Az , Azt => this % Azt , & g => p % g , gt => p % gt ) ! Update the residuals r = r - ( 0.0_wp , 1.0_wp ) * ( Az * g + g * Azt ) rt = rt + ( 0.0_wp , 1.0_wp ) * ( Azt * gt + gt * Az ) end associate end subroutine pure subroutine spinorbit_diffusion_equation_b ( this , p , r , rt ) !! Calculate the spin-orbit coupling terms in the right boundary condition, and update the residuals. class ( spinorbit ), target , intent ( in ) :: this type ( propagator ), intent ( in ) :: p type ( spin ), intent ( inout ) :: r , rt associate ( Az => this % Az , Azt => this % Azt , & g => p % g , gt => p % gt ) ! Update the residuals r = r - ( 0.0_wp , 1.0_wp ) * ( Az * g + g * Azt ) rt = rt + ( 0.0_wp , 1.0_wp ) * ( Azt * gt + gt * Az ) end associate end subroutine end module","tags":"","loc":"sourcefile/spinorbit.f.html","title":"spinorbit.f – ​"},{"text":"Contents Modules material_m Source Code material.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'material',  which models the state of a physical material for a discretized range of !> positions and energies. This is an abstract type, meaning that it is not intended to be instantiated on its own, but is !> intended as a base type for physical materials like conductors, superconductors, and ferromagnets. In other words, this !> type defines the essential data structures and program structure, while the derived subtypes will define actual physics. module material_m use :: stdio_m use :: condmat_m private ! Public declarations public :: material_conf , material_load ! Type declarations type , public , abstract :: material ! Material properties that affect the equilibrium state real ( wp ) :: length = 1.00_wp !! Material length (L/ξ) real ( wp ) :: thouless = 1.00_wp !! Thouless energy (ħD/L²) real ( wp ) :: scattering = 0.01_wp !! Inelastic scattering (η/Δ₀) logical :: transparent_a = . false . !! Interface transparency (left) logical :: transparent_b = . false . !! Interface transparency (right) logical :: phaselock = . false . !! Lock the center-of-mass phase? ! Material properties that affect the nonequilibrium state logical :: equilibrium = . true . !! Equilibrium? logical :: transverse = . false . !! Transverse potential gradients? real ( wp ) :: voltage = 0.00_wp !! Voltage (eV/Δ₀) real ( wp ) :: temperature = 0.01_wp !! Temperature (T/Tc) real ( wp ) :: spinvoltage = 0.00_wp !! Spin-voltage (eVs/Δ₀) real ( wp ) :: spintemperature = 0.00_wp !! Spin-temperature (Ts/Tc) real ( wp ), dimension ( 1 : 3 ) :: spinaxis = [ 0 , 0 , 1 ] !! Spin quantization axis ! Physical state modelled using quasiclassical propagators real ( wp ), allocatable :: energy (:) !! Energy domain real ( wp ), allocatable :: location (:) !! Position domain type ( propagator ), allocatable :: propagator (:,:) !! Propagator values type ( propagator ), allocatable :: backup (:,:) !! Propagator backups ! Physical observables derived from the propagators above real ( wp ), allocatable :: density (:,:,:) !! Spin-resolved density of states real ( wp ), allocatable :: supercurrent (:,:) !! Charge, spin, heat, and spin-heat supercurrents real ( wp ), allocatable :: lossycurrent (:,:) !! Charge, spin, heat, and spin-heat dissipative currents real ( wp ), allocatable :: accumulation (:,:) !! Charge, spin, heat, and spin-heat accumulation real ( wp ), allocatable :: magnetization (:,:) !! Magnetization due to exchange and Zeeman effects complex ( wp ), allocatable :: correlation (:) !! Superconducting pair-correlations ! Hybrid structures are modeled as double-linked lists integer :: order = 1 !! Simulation priority of this material class ( material ), pointer :: material_a => null () !! Material to the left  (default: vacuum) class ( material ), pointer :: material_b => null () !! Material to the right (default: vacuum) ! Control parameters for the numerical solvers integer :: iteration = 0 !! Used to keep track of selfconsistent iteration cycles integer :: selfconsistency = 2 !! Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer :: scaling = 128 !! Maximal mesh increase (range: 2&#94;N, N>1) integer :: method = 4 !! Runge—Kutta order (range: 2, 4, 6) integer :: control = 2 !! Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real ( wp ) :: tolerance = 1 e - 10_wp !! Error tolerance (maximum defect or global error) integer :: information = 0 !! Debug information (range: [-1,2]) real ( wp ) :: difference = 1 e + 10_wp !! Difference between iterations ! The following variables are used for input/output purposes, and should be modified by class(material) constructors character ( len = 128 ) :: type_string = 'MATERIAL' !! Name of this material contains ! These methods define how to update the physical state of the material procedure ( manipulate ), deferred :: construct !! Construct  object procedure ( initialize ), deferred :: initialize !! Initialize object procedure ( manipulate ), deferred :: update_prehook !! Executed before update procedure ( manipulate ), deferred :: update_posthook !! Executed after  update procedure :: update => material_update !! Calculate propagators procedure :: update_diffusion => diffusion_update !! Calculate propagators (in equilibrium) procedure :: update_kinetic => kinetic_update !! Calculate propagators (nonequilibrium) ! These methods define the physical equations used by the update methods procedure ( diffusion_equation ), deferred :: diffusion_equation !! Diffusion equation procedure ( diffusion_equation_a ), deferred :: diffusion_equation_a !! Boundary condition (left) procedure ( diffusion_equation_b ), deferred :: diffusion_equation_b !! Boundary condition (right) procedure ( kinetic_equation ), deferred :: kinetic_equation !! Kinetic equation procedure ( kinetic_equation_a ), deferred :: kinetic_equation_a !! Boundary condition (left) procedure ( kinetic_equation_b ), deferred :: kinetic_equation_b !! Boundary condition (right) ! These methods define miscellaneous utility functions procedure :: conf => material_conf !! Configures material parameters procedure :: save => material_save !! Saves the state of the material procedure :: load => material_load !! Loads the state of the material end type ! Declare submodule procedures interface module subroutine kinetic_update ( this ) class ( material ), target , intent ( inout ) :: this end subroutine module subroutine diffusion_update ( this ) class ( material ), target , intent ( inout ) :: this end subroutine end interface ! Declare subclass procedures abstract interface subroutine initialize ( this ) !! This interface is used for the deferred procedure initialize. import material , wp class ( material ), intent ( inout ) :: this end subroutine subroutine manipulate ( this ) !! This interface is used for the deferred procedures construct, update_prehook, and update_posthook. import material class ( material ), intent ( inout ) :: this end subroutine pure subroutine diffusion_equation ( this , p , e , z ) !! This interface is used for the deferred procedure diffusion_equation. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( inout ) :: p complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z end subroutine pure subroutine diffusion_equation_a ( this , p , a , r , rt ) !! This interface is used for the deferred procedure diffusion_equation_a. import material , propagator , spin , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , a type ( spin ), intent ( inout ) :: r , rt end subroutine pure subroutine diffusion_equation_b ( this , p , b , r , rt ) !! This interface is used for the deferred procedure diffusion_equation_b. import material , propagator , spin , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , b type ( spin ), intent ( inout ) :: r , rt end subroutine pure subroutine kinetic_equation ( this , Gp , R , z ) !! This interface is used for the deferred procedure kinetic_equation. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z end subroutine pure subroutine kinetic_equation_a ( this , Gp , Ga , Cp , Ca ) !! This interface is used for the deferred procedure kinetic_equation_a. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Ga complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Ca end subroutine pure subroutine kinetic_equation_b ( this , Gp , Gb , Cp , Cb ) !! This interface is used for the deferred procedure kinetic_equation_b. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Gb complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Cb end subroutine end interface contains !--------------------------------------------------------------------------------! !                    IMPLEMENTATION OF STATE UPDATE METHODS                      ! !--------------------------------------------------------------------------------! impure subroutine material_update ( this , bootstrap ) !! This subroutine updates the state of the material by solving the diffusion !! equations for the equilibrium propagators, the kinetic equations for the !! nonequilibrium propagators, and then calculating physical observables. class ( material ), intent ( inout ) :: this !! Material that will be updated logical , optional , intent ( in ) :: bootstrap !! Disable calculation of observables ! Only update materials with a positive order if ( this % order <= 0 ) then return end if ! Call the prehook method call this % update_prehook ! Status information if ( this % information >= 0 ) then block character ( len = 10 ) :: str write ( str , '(2x,\"\u001b[1m#\",i0)' ) this % order write ( stdout , '(a,a,20x)' ) str , trim ( this % type_string ) end block end if ! Reset the difference since last update to zero this % difference = 0.0_wp ! Solve the diffusion equations call this % update_diffusion ! Solve the kinetic equations if (. not . this % equilibrium ) then call this % update_kinetic end if ! Status information if ( this % information >= 0 ) then write ( stdout , '(6x,a,f10.8,a)' ) 'Max change: ' , this % difference , '                                        ' flush ( stdout ) end if ! Stop here if bootstrapping if ( present ( bootstrap )) then if ( bootstrap ) then return end if end if ! Call the posthook method call this % update_posthook end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! impure subroutine material_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( material ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val select case ( key ) case ( \"length\" ) call evaluate ( val , this % length ) this % thouless = 1 / ( this % length ** 2 + eps ) case ( \"scattering\" ) call evaluate ( val , this % scattering ) case ( \"temperature\" ) call evaluate ( val , this % temperature ) case ( \"voltage\" ) call evaluate ( val , this % voltage ) case ( \"spinvoltage\" ) call evaluate ( val , this % spinvoltage ) case ( \"spintemperature\" ) call evaluate ( val , this % spintemperature ) case ( \"spinaxis\" ) call evaluate ( val , this % spinaxis ) this % spinaxis = unitvector ( this % spinaxis ) case ( \"transverse\" ) call evaluate ( val , this % transverse ) case ( \"transparent_a\" ) call evaluate ( val , this % transparent_a ) case ( \"transparent_b\" ) call evaluate ( val , this % transparent_b ) case ( \"order\" ) call evaluate ( val , this % order ) if ( this % order > 16 ) then call error ( \"The order of the material must be be maximum 16.\" ) else if ( this % order < 0 ) then call error ( \"The order of the material must be be minimum 0.\" ) end if case ( \"iteration\" ) call evaluate ( val , this % iteration ) case ( \"selfconsistency\" ) call evaluate ( val , this % selfconsistency ) if ( this % selfconsistency < 0 . or . this % selfconsistency > 2 ) then call error ( \"The selfconsistency scheme should be in the range [0,2].\" ) end if case ( \"phaselock\" ) call evaluate ( val , this % phaselock ) case ( \"equilibrium\" ) call evaluate ( val , this % equilibrium ) case default call error ( \"Unknown material option '\" // key // \"'.\" ) end select end subroutine impure subroutine material_save ( this ) !! Save a backup of the current material state. class ( material ), intent ( inout ) :: this ! Make sure the backup exists if (. not . allocated ( this % backup )) then allocate ( this % backup ( size ( this % propagator , 1 ), size ( this % propagator , 2 ))) end if ! Make a backup of the propagators call this % propagator % save ( this % backup ) end subroutine impure subroutine material_load ( this ) !! Load a backup of a previous material state. class ( material ), intent ( inout ) :: this integer :: info ! Load saved propagators call this % propagator % load ( this % backup ) ! Disable status messages info = this % information if ( this % information >= 0 ) then this % information = - 1 end if ! Silently recalculate derived properties call this % update_posthook ! Reenable status messages this % information = info end subroutine end module","tags":"","loc":"sourcefile/material.f.html","title":"material.f – ​"},{"text":"Contents Modules spinscattering_m Source Code spinscattering.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This submodule is included by conductor.f, and contains equations which model !> spin-flip scattering, spin-orbit scattering, and magnetic orbital depairing. module spinscattering_m use :: condmat_m use :: material_m private ! Public interface public spinscattering , spinscattering_construct ! Type declarations type :: spinscattering ! Metadata class ( material ), pointer :: material => null () !! Pointer to the material modelled by this instance type ( nambu ), dimension ( 0 : 7 ) :: nambuv !! Pauli matrices spanning the 4×4 Spin-Nambu space ! Physical fields real ( wp ) :: depairing = 0.0_wp !! Orbital depairing coefficient real ( wp ) :: spinflip = 0.0_wp !! Spin-flip  scattering coefficient (1/8τΔ) real ( wp ) :: spinorbit = 0.0_wp !! Spin-orbit scattering coefficient (1/8τΔ) contains procedure :: diffusion_equation => spinscattering_diffusion_equation !! Diffusion equation procedure :: kinetic_equation => spinscattering_kinetic_equation !! Kinetic equation end type ! Type constructors interface spinscattering module procedure spinscattering_construct end interface contains impure function spinscattering_construct ( parent ) result ( this ) !! Constructs a spinscattering object with a given parent material. type ( spinscattering ) :: this class ( material ), target :: parent integer :: i ! Save a pointer to the parent object this % material => parent ! Memoize the most used basis matrices do i = 0 , 7 this % nambuv ( i ) = nambuv ( i ) end do end function pure subroutine spinscattering_diffusion_equation ( this , p ) !! Calculate the spin-flip and spin-orbit scattering terms in the diffusion !! equation, and update the second derivatives of the Riccati parameters. class ( spinscattering ), intent ( in ) :: this type ( propagator ), intent ( inout ) :: p type ( nambu ) :: G , R type ( nambu ) :: Gsf , Gso , Gdp real ( wp ) :: Csf , Cso , Cdp ! Construct the propagator matrix G = p % retarded () ! Construct the self-energy matrices associate ( N => this % nambuv ) Gdp = N ( 4 ) * G * N ( 4 ) Gsf = N ( 1 ) * G * N ( 1 ) + N ( 2 ) * G * N ( 2 ) + N ( 3 ) * G * N ( 3 ) Gso = N ( 4 ) * Gsf * N ( 4 ) end associate ! Calculate the self-energy prefactors ! (including 1/2i from the Riccati-parametrized Usadel equation) Cdp = ( this % depairing ) / ( 2 * 4 * this % material % thouless ) Csf = ( this % spinflip ) / ( 2 * 1 * this % material % thouless ) Cso = ( this % spinorbit ) / ( 2 * 1 * this % material % thouless ) ! Calculate the self-energy commutators R = Cdp * Gdp + Csf * Gsf + Cso * Gso R = R * G - G * R ! Update the second derivatives of the Riccati parameters associate ( U => R % matrix , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) d2g = d2g + ( pauli0 - g * gt ) * ( U ( 1 : 2 , 3 : 4 ) - U ( 1 : 2 , 1 : 2 ) * g ) d2gt = d2gt + ( pauli0 - gt * g ) * ( U ( 3 : 4 , 1 : 2 ) - U ( 3 : 4 , 3 : 4 ) * gt ) end associate end subroutine pure subroutine spinscattering_kinetic_equation ( this , Gp , R ) !! Calculate the self-energies in the kinetic equation. class ( spinscattering ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R complex ( wp ) :: Csf , Cso , Cdp ! Calculate the self-energy prefactors Cdp = ( 0 , 1 ) * ( this % depairing ) / ( 4 * this % material % thouless ) Csf = ( 0 , 1 ) * ( this % spinflip ) / ( 1 * this % material % thouless ) Cso = ( 0 , 1 ) * ( this % spinorbit ) / ( 1 * this % material % thouless ) ! Calculate the self-energy contributions associate ( N => this % nambuv ) R = R & + Csf * Gp % selfenergy2 ( N ( 1 )) & + Csf * Gp % selfenergy2 ( N ( 2 )) & + Csf * Gp % selfenergy2 ( N ( 3 )) & + Cdp * Gp % selfenergy2 ( N ( 4 )) & + Cso * Gp % selfenergy2 ( N ( 5 )) & + Cso * Gp % selfenergy2 ( N ( 6 )) & + Cso * Gp % selfenergy2 ( N ( 7 )) end associate end subroutine end module","tags":"","loc":"sourcefile/spinscattering.f.html","title":"spinscattering.f – ​"},{"text":"Contents Programs voltage_p Source Code sweep_voltage.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> This program calculates the current-voltage relation of a one-dimensional superconducting structure. program voltage_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------------! !                                GLOBAL VARIABLES                                ! !--------------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack type ( conductor ), target :: na , nb ! Declare program control parameters real ( wp ), parameter :: threshold = 1 e - 2 real ( wp ), parameter :: tolerance = 1 e - 5 integer , parameter :: iterations = 100 ! Declare variables used by the program real ( wp ), dimension (:), allocatable :: voltage real ( wp ), dimension (:), allocatable :: current integer :: n !--------------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                             ! !--------------------------------------------------------------------------------! ! Redefine stdout and stderr stdout = output ( 'output.log' ) stderr = output ( 'error.log' ) ! Construct the central material stack stack = structure () ! Ensure that the voltage has an effect call stack % cmap ( 'equilibrium' , 'F' ) ! Construct the surrounding conductors call na % construct () call nb % construct () ! Disable the conductors from updates call na % conf ( 'order' , '0' ) call nb % conf ( 'order' , '0' ) ! Thermalize the surrounding conductors na % temperature = stack % a % temperature nb % temperature = stack % b % temperature ! Reinitialize the conductor states call na % initialize call nb % initialize ! Connect the conductors to the stack stack % a % material_a => na stack % b % material_b => nb ! Initialize the voltage and current allocate ( voltage ( iterations ), current ( iterations )) call linspace ( voltage , 1 e - 6_wp , 2.00_wp ) ! Start with a non-selfconsistent bootstrap procedure call stack % converge ( threshold = threshold , bootstrap = . true .) !--------------------------------------------------------------------------------! !                           LINEAR SEARCH PROCEDURE                              ! !--------------------------------------------------------------------------------! ! Calculate the charge current as a function of voltage difference current = 0 do n = 1 , size ( voltage ) ! Update the voltage na % voltage = + voltage ( n ) nb % voltage = - voltage ( n ) ! Reset the states call na % initialize call nb % initialize ! Update the state call stack % converge ( threshold = tolerance , prehook = prehook , posthook = posthook ) ! Save the charge current to array current ( n ) = stack % a % supercurrent ( 0 , 1 ) + stack % a % lossycurrent ( 0 , 1 ) ! Write out the results call finalize end do !--------------------------------------------------------------------------------! !                                 SUBROUTINES                                    ! !--------------------------------------------------------------------------------! contains impure subroutine prehook ! Write out status information. call status_body ( 'Voltage difference' , voltage ( n )) end subroutine impure subroutine posthook ! Write results to output files. character ( len = 5 ) :: filename write ( filename , '(f5.3)' ) voltage ( n ) end subroutine impure subroutine finalize ! Write the current-voltage relation to file call dump ( 'current.dat' , [ voltage , current ], [ 'Voltage           ' , 'Charge current    ' ]) end subroutine end program","tags":"","loc":"sourcefile/sweep_voltage.f.html","title":"sweep_voltage.f – ​"},{"text":"Contents Programs phase_p Source Code phase.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> This program calculates the phase-diagram of a one-dimensional superconducting structure. program phase_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------------! !                                GLOBAL VARIABLES                                ! !--------------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack ! Declare program control parameters integer , parameter :: bootstraps = 10 integer , parameter :: iterations = 10 real ( wp ), parameter :: threshold = 1 e - 8_wp ! Declare variables used by the program real ( wp ) :: flow real ( wp ) :: init !--------------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                             ! !--------------------------------------------------------------------------------! ! Redefine stdout and stderr stdout = output ( 'output.log' ) stderr = output ( 'error.log' ) ! Construct the material stack stack = structure () ! Use the fixpoint method for selfconsistency iterations call stack % cmap ( 'selfconsistency' , 1 ) ! Find out what gap the user has initialized the system to init = stack % gap () flow = 1.0 ! Reset the states of the propagators throughout the stack call stack % initialize ! Bootstrap the material states while locking the gap call stack % converge ( threshold = threshold , iterations = bootstraps , bootstrap = . true .) !--------------------------------------------------------------------------------! !                          PHASE DIAGRAM EVALUATION                              ! !--------------------------------------------------------------------------------! ! Update the material states call stack % converge ( iterations = iterations , prehook = prehook ) ! Calculate the gap changes flow = stack % gap () / init ! Write out the final results call finalize !--------------------------------------------------------------------------------! !                                 SUBROUTINES                                    ! !--------------------------------------------------------------------------------! contains impure subroutine prehook ! Write out status information. flow = stack % gap () / init call status_body ( 'Gap flow' , flow ) end subroutine impure subroutine finalize ! Status information call status_head ( 'PHASE DIAGRAM' ) call status_body ( 'Gap flow' , flow ) call status_foot ! Write the result to file call dump ( 'flow.dat' , flow ) ! Close output files close ( stdout ) close ( stderr ) end subroutine end program","tags":"","loc":"sourcefile/phase.f.html","title":"phase.f – ​"},{"text":"Contents Programs converge_p Source Code converge.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> This program calculates steady-state observables in a one-dimensional superconducting structure. program converge_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------------! !                                GLOBAL VARIABLES                                ! !--------------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack ! Declare program control parameters real ( wp ), parameter :: threshold = 1 e - 2 real ( wp ), parameter :: tolerance = 1 e - 8 !--------------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                             ! !--------------------------------------------------------------------------------! ! Redefine stdout and stderr stdout = output ( 'output.log' ) stderr = output ( 'error.log' ) ! Construct the superconducting structure stack = structure () ! Define output files stack % supercurrent = output ( 'supercurrent.dat' ) stack % lossycurrent = output ( 'lossycurrent.dat' ) stack % accumulation = output ( 'accumulation.dat' ) stack % distribution = output ( 'distribution.dat' ) stack % correlation = output ( 'correlation.dat' ) stack % magnetization = output ( 'magnetization.dat' ) stack % density = output ( 'density.dat' ) !--------------------------------------------------------------------------------! !                            CONVERGENCE PROCEDURE                               ! !--------------------------------------------------------------------------------! ! Non-selfconsistent bootstrap procedure call stack % converge ( threshold = threshold , bootstrap = . true .) ! Selfconsistent convergence procedure call stack % converge ( threshold = tolerance ) ! Write out the final results call finalize !--------------------------------------------------------------------------------! !                                 SUBROUTINES                                    ! !--------------------------------------------------------------------------------! contains impure subroutine finalize ! Status information call status_head ( 'STEADY STATE' ) call status_body ( 'State difference' , stack % difference ()) call status_body ( 'Charge violation' , stack % chargeviolation ()) call status_foot ! Close output files close ( stdout ) close ( stderr ) end subroutine end program","tags":"","loc":"sourcefile/converge.f.html","title":"converge.f – ​"},{"text":"Contents Programs critical_p Source Code critical.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> This program calculates the critical temperature of a one-dimensional superconducting structure. program critical_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------------! !                                GLOBAL VARIABLES                                ! !--------------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack ! Declare program control parameters integer , parameter :: bisections = 20 integer , parameter :: bootstraps = 10 integer , parameter :: iterations = 10 real ( wp ), parameter :: threshold = 1 e - 08_wp real ( wp ), parameter :: initgap = 1 e - 02_wp ! Declare variables used by the program real ( wp ) :: minimum = 0.00_wp real ( wp ) :: maximum = 1.00_wp real ( wp ) :: critical = 0.50_wp integer :: n = 0 !--------------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                             ! !--------------------------------------------------------------------------------! ! Redefine stdout and stderr stdout = output ( 'output.log' ) stderr = output ( 'error.log' ) ! Construct the material stack stack = structure () ! Use the fixpoint method for selfconsistency iterations call stack % cmap ( 'selfconsistency' , 1 ) ! Initialize the stack to a barely superconducting state call stack % cmap ( 'gap' , initgap ) ! Reset the states of the propagators throughout the stack call stack % initialize ! Bootstrap the material states while locking the gap call stack % converge ( threshold = threshold , iterations = bootstraps , bootstrap = . true .) ! Save the current state of the materials call stack % save !--------------------------------------------------------------------------------! !                           BINARY SEARCH PROCEDURE                              ! !--------------------------------------------------------------------------------! do n = 1 , bisections ! Set the temperature of the materials call stack % cmap ( 'temperature' , critical ) ! Reinitialize at the new temperature call stack % initialize ! Load the saved material states call stack % load ! Update the material states call stack % converge ( iterations = iterations , prehook = prehook ) ! Update the critical temperature estimate if ( stack % gap () >= initgap ) then minimum = critical else maximum = critical end if critical = ( minimum + maximum ) / 2 end do ! Write out the final results call finalize !--------------------------------------------------------------------------------! !                                 SUBROUTINES                                    ! !--------------------------------------------------------------------------------! contains impure subroutine prehook ! Write out status information. call status_body ( 'Temperature' , critical ) call status_body ( 'Bisection' , n ) end subroutine impure subroutine finalize ! Status information call status_head ( 'CRITICAL TEMPERATURE' ) call status_body ( 'Result' , critical ) call status_foot ! Write the result to file call dump ( 'critical.dat' , critical ) ! Close output files close ( stdout ) close ( stderr ) end subroutine end program","tags":"","loc":"sourcefile/critical.f.html","title":"critical.f – ​"},{"text":"Contents Programs phase_p Source Code sweep_phase.f Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> This program calculates the current-phase relation of a one-dimensional superconducting structure. program phase_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------------! !                                GLOBAL VARIABLES                                ! !--------------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack type ( superconductor ), target :: sa , sb ! Declare program control parameters real ( wp ), parameter :: threshold = 1 e - 2 real ( wp ), parameter :: tolerance = 1 e - 8 integer , parameter :: iterations = 51 ! Declare variables used by the program real ( wp ), dimension (:), allocatable :: phase real ( wp ), dimension (:), allocatable :: current real ( wp ) :: critical integer :: n , m !--------------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                             ! !--------------------------------------------------------------------------------! ! Redefine stdout and stderr stdout = output ( 'output.log' ) stderr = output ( 'error.log' ) ! Construct the central material stack stack = structure () ! Construct the surrounding superconductors call sa % construct () call sb % construct () ! Disable the superconductors from updates call sa % conf ( 'order' , '0' ) call sb % conf ( 'order' , '0' ) ! Connect the superconductors to the stack stack % a % material_a => sa stack % b % material_b => sb ! Count the number of superconductors n = stack % superconductors () ! Depending on the number of enabled superconductors in the junction, we might get a ! 2πn-periodicity instead of a 2π-periodicity, and should therefore account for that. m = ( n + 1 ) * ( iterations - 1 ) + 1 allocate ( phase ( m ), current ( m )) call linspace ( phase , 1 e - 6_wp , 2 * ( n + 1 ) - 1 e - 6_wp ) ! Start with a non-selfconsistent bootstrap procedure call stack % converge ( threshold = threshold , bootstrap = . true .) !--------------------------------------------------------------------------------! !                           LINEAR SEARCH PROCEDURE                              ! !--------------------------------------------------------------------------------! ! Calculate the charge current as a function of phase difference do n = 1 , size ( phase ) ! Update the phase sa % correlation = exp ((( 0.0 , - 0.5 ) * pi ) * phase ( n )) sb % correlation = exp ((( 0.0 , + 0.5 ) * pi ) * phase ( n )) ! Reset the states call sa % initialize call sb % initialize ! Update the state call stack % converge ( threshold = tolerance , prehook = prehook , posthook = posthook ) ! Save the charge current to array current ( n ) = stack % a % supercurrent ( 0 , 1 ) end do ! Calculate the critical current critical = maxval ( abs ( current )) ! Write out the final results call finalize !--------------------------------------------------------------------------------! !                                 SUBROUTINES                                    ! !--------------------------------------------------------------------------------! contains impure subroutine prehook ! Write out status information. call status_body ( 'Phase difference' , phase ( n )) end subroutine impure subroutine posthook ! Write results to output files. character ( len = 5 ) :: filename write ( filename , '(f5.3)' ) phase ( n ) !   call stack % write_supercurrent('current.' // filename // '.dat') !   call stack % write_gap(         'gap.'     // filename // '.dat') end subroutine impure subroutine finalize ! Status information call status_head ( 'CRITICAL CURRENT' ) call status_body ( 'Result' , critical ) call status_foot ! Write the current-phase relation to file call dump ( 'current.dat' , [ phase , current ], [ 'Phase             ' , 'Charge current    ' ]) ! Write the critical current to file call dump ( 'critical.dat' , critical ) ! Close output files close ( stdout ) close ( stderr ) end subroutine end program","tags":"","loc":"sourcefile/sweep_phase.f.html","title":"sweep_phase.f – ​"},{"text":"type, public :: propagator Contents Variables g gt dg dgt d2g d2gt N Nt h dh d2h Constructor propagator Type-Bound Procedures retarded retarded_gradient retarded_laplacian advanced advanced_gradient advanced_laplacian keldysh keldysh_gradient distribution distribution_gradient dissipation dissipation_gradient condensate condensate_gradient selfenergy1 selfenergy2 supercurrent lossycurrent accumulation correlation density save load Components Type Visibility Attributes Name Initial type( spin ), public :: g Riccati parameter γ type( spin ), public :: gt Riccati parameter γ~ type( spin ), public :: dg Riccati parameter ∇γ type( spin ), public :: dgt Riccati parameter ∇γ~ type( spin ), public :: d2g Riccati parameter ∇²γ type( spin ), public :: d2gt Riccati parameter ∇²γ~ type( spin ), public :: N Riccati normalization N type( spin ), public :: Nt Riccati normalization N~ real(kind=wp), public, dimension(0:7) :: h = [1, 0, 0, 0, 0, 0, 0, 0] Distribution-trace H real(kind=wp), public, dimension(0:7) :: dh = [0, 0, 0, 0, 0, 0, 0, 0] Distribution-trace ∇H real(kind=wp), public, dimension(0:7) :: d2h = [0, 0, 0, 0, 0, 0, 0, 0] Distribution-trace ∇²H Constructor public interface propagator private pure function propagator_construct_vacuum() result(this) Construct a vacuum propagator, i.e. a propagator which satisfies G=0. Arguments None Return Value type( propagator ) Constructed object private pure function propagator_construct_riccati(g, gt, dg, dgt) result(this) Construct an arbitrary state by explicitly providing the Riccati parameters.\n Unspecified Riccati parameters default to zero due to the spin constructors.\n The distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: g Riccati parameter γ type( spin ), intent(in) :: gt Riccati parameter γ~ type( spin ), intent(in), optional :: dg Riccati parameter ∇γ type( spin ), intent(in), optional :: dgt Riccati parameter ∇γ~ Return Value type( propagator ) Constructed object private pure function propagator_construct_bcs(energy, gap) result(this) Constructs a state corresponding to a BCS superconductor at some given energy,\n which may have an imaginary term representing inelastic scattering. The second\n argument 'gap' is used to provide the superconducting order parameter Δ.\n The distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: energy Quasiparticle energy (including inelastic scattering contribution) complex(kind=wp), intent(in) :: gap Superconducting order parameter (including superconducting phase) Return Value type( propagator ) Constructed object Type-Bound Procedures procedure, public :: retarded => propagator_retarded Retarded propagator G&#94;R private pure function propagator_retarded(this) result(GR) Calculates the 4×4 retarded propagator G&#94;R. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Retarded propagator procedure, public :: retarded_gradient => propagator_retarded_gradient Retarded propagator ∇G&#94;R private pure function propagator_retarded_gradient(this, gauge) result(dGR) Calculates the 4×4 retarded propagator gradient ∇G&#94;R. If an optional\n gauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Retarded propagator gradient procedure, public :: retarded_laplacian => propagator_retarded_laplacian Retarded propagator ∇²G&#94;R private pure function propagator_retarded_laplacian(this) result(d2GR) Calculates the 4×4 retarded propagator gradient ∇²G&#94;R. Read more… Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Retarded propagator laplacian procedure, public :: advanced => propagator_advanced Advanced propagator G&#94;A private pure function propagator_advanced(this) result(GA) Calculates the 4×4 advanced propagator G&#94;A. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Advanced propagator procedure, public :: advanced_gradient => propagator_advanced_gradient Advanced propagator ∇G&#94;A private pure function propagator_advanced_gradient(this, gauge) result(dGA) Calculates the 4×4 advanced propagator gradient ∇G&#94;A. If an optional\n gauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Advanced propagator gradient procedure, public :: advanced_laplacian => propagator_advanced_laplacian Advanced propagator ∇²G&#94;A private pure function propagator_advanced_laplacian(this) result(d2GA) Calculates the 4×4 retarded propagator gradient ∇²G&#94;A. Read more… Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Advanced propagator laplacian procedure, public :: keldysh => propagator_keldysh Keldysh propagator G&#94;K private pure function propagator_keldysh(this) result(GK) Calculates the 4×4 Keldysh propagator G&#94;K. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Propagator matrix procedure, public :: keldysh_gradient => propagator_keldysh_gradient Keldysh propagator ∇G&#94;K private pure function propagator_keldysh_gradient(this, gauge) result(dGK) Calculates the 4×4 Keldysh propagator gradient ∇G&#94;K. If an optional\n gauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Propagator gradient procedure, public :: distribution => propagator_distribution Distribution matrix H private pure function propagator_distribution(this) result(H) Calculates the 4×4 distribution function matrix H. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Distribution matrix procedure, public :: distribution_gradient => propagator_distribution_gradient Distribution matrix ∇H private pure function propagator_distribution_gradient(this, gauge) result(dH) Calculates the 4×4 distribution function gradient ∇H. If an optional\n gauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Distribution gradient procedure, public :: dissipation => propagator_dissipation Dissipation matrix M private pure function propagator_dissipation(this) result(M) Calculate the dissipation matrix M = ∂J/∂H', where J is the\n current and H' is the gradient of the distribution function. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7,0:7) procedure, public :: dissipation_gradient => propagator_dissipation_gradient Dissipation matrix ∇M private pure function propagator_dissipation_gradient(this) result(dM) Calculate the gradient of the dissipation matrix M'. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7,0:7) procedure, public :: condensate => propagator_condensate Condensate matrix Q private pure function propagator_condensate(this) result(Q) Calculate the condensate matrix Q = ∂J/∂H, where J is the\n current and H is the nonequilibrium distribution function. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7,0:7) procedure, public :: condensate_gradient => propagator_condensate_gradient Condensate matrix ∇Q private pure function propagator_condensate_gradient(this) result(dQ) Calculate the gradient of the condensate matrix Q'. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7,0:7) procedure, public :: selfenergy1 => propagator_selfenergy1 Selfenergy matrix R₁ private pure function propagator_selfenergy1(this, S) result(R) Calculate the 1st-order self-energy contribution to the kinetic equations. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this type( nambu ), intent(in) :: S Return Value complex(kind=wp),\n  dimension(0:7,0:7) procedure, public :: selfenergy2 => propagator_selfenergy2 Selfenergy matrix R₂ private pure function propagator_selfenergy2(this, S) result(R) Calculate the 2nd-order self-energy contribution to the kinetic equations. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this type( nambu ), intent(in) :: S Return Value complex(kind=wp),\n  dimension(0:7,0:7) procedure, public :: supercurrent => propagator_supercurrent Spectral supercurrents private pure function propagator_supercurrent(this, gauge) result(J) Calculates the spectral supercurrents in the junction. The result is returned in the\n form of an 8-vector containing the charge, spin, heat, and spin-heat currents. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value real(kind=wp),\n  dimension(0:7) Spectral supercurrent procedure, public :: lossycurrent => propagator_lossycurrent Spectral dissipative currents private pure function propagator_lossycurrent(this, gauge) result(J) Calculates the spectral dissipative currents in the junction. The result is returned in\n the form of an 8-vector containing the charge, spin, heat, and spin-heat currents. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value real(kind=wp),\n  dimension(0:7) Spectral dissipative current procedure, public :: accumulation => propagator_accumulation Spectral accumulations private pure function propagator_accumulation(this) result(Q) Calculates the spectral accumulations in the junction. The result is returned in the\n form of an 8-vector containing the charge, spin, heat, and spin-heat accumulations. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value real(kind=wp),\n  dimension(0:7) Spectral accumulation procedure, public :: correlation => propagator_correlation Spectral correlations private pure function propagator_correlation(this) result(r) Calculates the spectral pair-correlation function. This is useful e.g. for\n self-consistently calculating the superconducting gap in a superconductor. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value complex(kind=wp) Spectral correlation procedure, public :: density => propagator_density Spin-resolved density of states private pure function propagator_density(this) result(D) Calculates the spin-resolved local density of states. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value real(kind=wp),\n  dimension(0:7) procedure, public :: save => propagator_save Export Riccati parameters private pure elemental subroutine propagator_save(this, other) Defines a function for exporting Riccati parameters. Arguments Type Intent Optional Attributes Name class( propagator ), intent(inout) :: this class( propagator ), intent(inout) :: other procedure, public :: load => propagator_load Import Riccati parameters private pure elemental subroutine propagator_load(this, other) Defines a function for importing Riccati parameters. Arguments Type Intent Optional Attributes Name class( propagator ), intent(inout) :: this class( propagator ), intent(inout) :: other","tags":"","loc":"type/propagator.html","title":"propagator – ​ "},{"text":"type, public :: nambu Contents Variables matrix Type-Bound Procedures nambu assignment(=) operator(+) operator(-) operator(*) operator(/) operator(**) Components Type Visibility Attributes Name Initial complex(kind=wp), public :: matrix (4,4) = 0.0_wp Encapsulate a spin and Nambu space matrix Type-Bound Procedures generic, public :: nambu => cons_rscalar, cons_cscalar, cons_cmatrix, cons_nambu private pure function nambu_cons_rscalar(other) result(this) Constructs a nambu object from a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_cons_cscalar(other) result(this) Constructs a nambu object from a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_cons_cmatrix(other) result(this) Constructs a nambu object from a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private pure function nambu_cons_nambu(other) result(this) Constructs a nambu object from an existing one. Arguments Type Intent Optional Attributes Name type( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assl_cmatrix private pure subroutine nambu_assr_rscalar(this, other) Imports data to a nambu object from a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(inout) :: this real(kind=wp), intent(in) :: other private pure subroutine nambu_assr_cscalar(this, other) Imports data to a nambu object from a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(inout) :: this complex(kind=wp), intent(in) :: other private pure subroutine nambu_assr_cmatrix(this, other) Imports data to a nambu object from a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(inout) :: this complex(kind=wp), intent(in) :: other (4,4) private pure subroutine nambu_assl_cmatrix(other, this) Exports data from a nambu object to a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(out) :: other (4,4) class( nambu ), intent(in) :: this generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_nambu private pure function nambu_addl_rscalar(other, this) result(r) Defines left addition of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_addr_rscalar(this, other) result(r) Defines right addition of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_addl_cscalar(other, this) result(r) Defines left addition of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_addr_cscalar(this, other) result(r) Defines right addition of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_addl_cmatrix(other, this) result(r) Defines left addition of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_addr_cmatrix(this, other) result(r) Defines right addition of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private pure elemental function nambu_add_nambu(this, other) result(r) Defines addition of two nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this class( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_nambu private pure function nambu_subl_rscalar(other, this) result(r) Defines left subtraction of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_subr_rscalar(this, other) result(r) Defines right subtraction of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_subl_cscalar(other, this) result(r) Defines left subtraction of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_subr_cscalar(this, other) result(r) Defines right subtraction of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_subl_cmatrix(other, this) result(r) Defines left subtraction of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_subr_cmatrix(this, other) result(r) Defines right subtraction of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private pure elemental function nambu_sub_nambu(this, other) result(r) Defines subtraction of two nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this class( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_nambu private pure function nambu_mull_rscalar(other, this) result(r) Defines left multiplication of a nambu matrix by a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_mulr_rscalar(this, other) result(r) Defines right multiplication of a nambu matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_mull_cscalar(other, this) result(r) Defines left multiplication of a nambu matrix by a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private function nambu_mulr_cscalar(this, other) result(r) Defines right multiplication of a nambu matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_mull_cmatrix(other, this) result(r) Defines left multiplication of a nambu matrix by a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_mulr_cmatrix(this, other) result(r) Defines right multiplication of a nambu matrix by a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private pure elemental function nambu_mul_nambu(this, other) result(r) Defines multiplication of two nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this class( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: operator(/) => divr_rscalar, divr_cscalar private pure function nambu_divr_rscalar(this, other) result(r) Defines division of a nambu matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_divr_cscalar(this, other) result(r) Defines division of a nambu matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) generic, public :: operator(**) => expr_iscalar private pure function nambu_expr_iscalar(this, other) result(r) Exponentiates the nambu object, where the power is a positive integer. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this integer, intent(in) :: other Return Value type( nambu )","tags":"","loc":"type/nambu.html","title":"nambu – ​ "},{"text":"type, public :: spin Contents Variables matrix Type-Bound Procedures spin assignment(=) operator(+) operator(-) operator(*) operator(/) operator(**) Components Type Visibility Attributes Name Initial complex(kind=wp), public :: matrix (2,2) = 0.0_wp Encapsulate a spin matrix Type-Bound Procedures generic, public :: spin => cons_rscalar, cons_cscalar, cons_cmatrix, cons_rvector, cons_spin private pure function spin_cons_rscalar(other) result(this) Constructs a spin object from a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_cons_cscalar(other) result(this) Constructs a spin object from a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_cons_cmatrix(other) result(this) Constructs a spin object from a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private pure function spin_cons_rvector(other) result(this) Constructs a spin object from a real vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other (8) Return Value type( spin ) private pure function spin_cons_spin(other) result(this) Constructs a spin object from an existing one. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: other Return Value type( spin ) generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assr_rvector, assl_cmatrix, assl_rvector private pure subroutine spin_assr_rscalar(this, other) Imports data to a spin object from a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this real(kind=wp), intent(in) :: other private pure subroutine spin_assr_cscalar(this, other) Imports data to a spin object from a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this complex(kind=wp), intent(in) :: other private pure subroutine spin_assr_cmatrix(this, other) Imports data to a spin object from a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this complex(kind=wp), intent(in) :: other (2,2) private pure subroutine spin_assr_rvector(this, other) Imports data to a spin object from a real vector. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this real(kind=wp), intent(in) :: other (8) private pure subroutine spin_assl_cmatrix(other, this) Exports data from a spin object to a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(out) :: other (2,2) class( spin ), intent(in) :: this private pure subroutine spin_assl_rvector(other, this) Exports data from a spin object to a real vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: other (8) class( spin ), intent(in) :: this generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_spin private pure function spin_addl_rscalar(other, this) result(r) Defines left addition of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_addr_rscalar(this, other) result(r) Defines right addition of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_addl_cscalar(other, this) result(r) Defines left addition of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_addr_cscalar(this, other) result(r) Defines right addition of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_addl_cmatrix(other, this) result(r) Defines left addition of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_addr_cmatrix(this, other) result(r) Defines right addition of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private pure elemental function spin_add_spin(this, other) result(r) Defines addition of two spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this class( spin ), intent(in) :: other Return Value type( spin ) generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_spin private pure function spin_subl_rscalar(other, this) result(r) Defines left subtraction of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_subr_rscalar(this, other) result(r) Defines right subtraction of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_subl_cscalar(other, this) result(r) Defines left subtraction of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_subr_cscalar(this, other) result(r) Defines right subtraction of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_subl_cmatrix(other, this) result(r) Defines left subtraction of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_subr_cmatrix(this, other) result(r) Defines right subtraction of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private pure elemental function spin_sub_spin(this, other) result(r) Defines subtraction of two spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this class( spin ), intent(in) :: other Return Value type( spin ) generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_spin private pure function spin_mull_rscalar(other, this) result(r) Defines left multiplication of a spin matrix by a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_mulr_rscalar(this, other) result(r) Defines right multiplication of a spin matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_mull_cscalar(other, this) result(r) Defines left multiplication of a spin matrix by a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private function spin_mulr_cscalar(this, other) result(r) Defines right multiplication of a spin matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_mull_cmatrix(other, this) result(r) Defines left multiplication of a spin matrix by a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_mulr_cmatrix(this, other) result(r) Defines right multiplication of a spin matrix by a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private pure elemental function spin_mul_spin(this, other) result(r) Defines multiplication of two spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this class( spin ), intent(in) :: other Return Value type( spin ) generic, public :: operator(/) => divr_rscalar, divr_cscalar private pure function spin_divr_rscalar(this, other) result(r) Defines division of a spin matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_divr_cscalar(this, other) result(r) Defines division of a spin matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) generic, public :: operator(**) => expr_iscalar private pure function spin_expr_iscalar(this, other) result(r) Exponentiates the spin object, where the power is a positive integer. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this integer, intent(in) :: other Return Value type( spin )","tags":"","loc":"type/spin.html","title":"spin – ​ "},{"text":"type, public :: structure Contents Variables a b supercurrent lossycurrent accumulation correlation magnetization distribution density Constructor structure Type-Bound Procedures push conf cmap fmap initialize save load update update_prehook update_posthook converge write difference materials selfconsistency superconductors chargeviolation gap Components Type Visibility Attributes Name Initial class( material ), public, pointer :: a => null() First material class( material ), public, pointer :: b => null() Last  material integer, public, allocatable :: supercurrent Output unit (allocate to write supercurrents  to file) integer, public, allocatable :: lossycurrent Output unit (allocate to write lossycurrents  to file) integer, public, allocatable :: accumulation Output unit (allocate to write accumulations  to file) integer, public, allocatable :: correlation Output unit (allocate to write correlations   to file) integer, public, allocatable :: magnetization Output unit (allocate to write magnetizations to file) integer, public, allocatable :: distribution Output unit (allocate to write distributions  to file) integer, public, allocatable :: density Output unit (allocate to write density of states to file) Constructor public interface structure private impure function structure_construct() result(this) Constructs a multilayer stack from a configuration file. Arguments None Return Value type( structure ) Type-Bound Procedures procedure, public :: push => structure_push Construct a single layer private impure subroutine structure_push(this, string) Constructs a new class(material) object at the bottom of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), intent(inout) :: this character(len=*), intent(in) :: string procedure, public :: conf => structure_conf Configure a single layer private impure subroutine structure_conf(this, key, val) Configures the last material pushed to the multilayer stack. Read more… Arguments Type Intent Optional Attributes Name class( structure ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val procedure, public :: cmap => structure_cmap Configure  all layers private impure subroutine structure_cmap(this, key, val) Maps a configuration option onto each element of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), intent(inout) :: this character(len=*), intent(in) :: key class(*), intent(in) :: val procedure, public :: fmap => structure_fmap Manipulate all layers private impure subroutine structure_fmap(this, routine, every) Maps a subroutine onto each element of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure(mappable) :: routine logical, optional :: every procedure, public :: initialize => structure_initialize Reset the physical state private impure subroutine structure_initialize(this) Initializes the state of the entire multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: save => structure_save Save the physical state private impure subroutine structure_save(this) Saves the state of the entire multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: load => structure_load Load the physical state private impure subroutine structure_load(this) Loads the saved state of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: update => structure_update Update the physical state private impure subroutine structure_update(this, bootstrap) Updates the state of the entire multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this logical, optional :: bootstrap procedure, public :: update_prehook => structure_update_prehook Execute all update prehooks private impure subroutine structure_update_prehook(this) Silently execute all update prehooks. Arguments Type Intent Optional Attributes Name class( structure ) :: this procedure, public :: update_posthook => structure_update_posthook Execute all update posthooks private impure subroutine structure_update_posthook(this) Silently execute all update posthooks. Arguments Type Intent Optional Attributes Name class( structure ) :: this procedure, public :: converge => structure_converge Update until convergence private impure subroutine structure_converge(this, threshold, iterations, bootstrap, prehook, posthook) Performs a convergence procedure, where the state of every material in the stack\n is repeatedly updated until the residuals drop below some specified threshold \n and/or a certain number of iterations have been performed. If bootstrap is set\n to true, the selfconsistency equations will only be solved once at the end, but\n not inbetween the individual iterations. If a prehook and/or posthook is given,\n those subroutines will be executed before/after each iteration of the update. Arguments Type Intent Optional Attributes Name class( structure ), target :: this real(kind=wp), optional :: threshold integer, optional :: iterations logical, optional :: bootstrap procedure(hook), optional :: prehook procedure(hook), optional :: posthook procedure, public :: write => structure_write Write out observables private impure subroutine structure_write(this) Writes physical observables to output files. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: difference => structure_difference Check how much the physical state changes private impure function structure_difference(this) result(difference) Checks how much the multilayer stack has changed recently. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value real(kind=wp) procedure, public :: materials => structure_materials Check the number of enabled materials private impure function structure_materials(this) result(num) Checks the number of enabled materials in the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value integer procedure, public :: selfconsistency => structure_selfconsistency Whether selfconsistency iteration is required private impure function structure_selfconsistency(this) result(res) Checks whether selfconsistency iteration is required. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value logical procedure, public :: superconductors => structure_superconductors Check the number of enables superconductors private impure function structure_superconductors(this) result(num) Checks the number of selfconsistent superconductors in the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value integer procedure, public :: chargeviolation => structure_chargeviolation Check the violation of charge conservation private impure function structure_chargeviolation(this) result(difference) Checks how much the charge current varies with position. Since charge current\n is supposed to be conserved through the junction, this provides a measure of\n charge conservation violation, i.e. if the solution is physically realistic. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value real(kind=wp) procedure, public :: gap => structure_gap Check the minimum superconducting gap private impure function structure_gap(this) result(gap) Obtains the mean gap in the enabled superconductor. If there are multiple such\n superconductors in the junction, then it returns the minimum of the mean gaps. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value real(kind=wp)","tags":"","loc":"type/structure.html","title":"structure – ​ "},{"text":"type, public :: spinactive Contents Variables conductance polarization spinmixing secondorder magnetization misalignment0 misalignment1 Type-Bound Procedures diffusion_current kinetic_current update_prehook Components Type Visibility Attributes Name Initial real(kind=wp), public :: conductance = 1.0 Interfacial conductance real(kind=wp), public :: polarization = 0.0 Interfacial spin-polarization real(kind=wp), public :: spinmixing = 0.0 Interfacial 1st-order spin-mixing real(kind=wp), public :: secondorder = 0.0 Interfacial 2nd-order spin-mixing real(kind=wp), public, dimension(1:3) :: magnetization = [0, 0, 1] Interfacial magnetization direction real(kind=wp), public, dimension(1:3) :: misalignment0 = [0, 0, 0] Interfacial magnetization misalignment (this  side) real(kind=wp), public, dimension(1:3) :: misalignment1 = [0, 0, 0] Interfacial magnetization misalignment (other side) Type-Bound Procedures procedure, public :: diffusion_current => spinactive_diffusion_current private pure function spinactive_diffusion_current(this, G0, G1) result(I) Calculate the matrix current at an interface with spin-active properties. The equations\n implemented here should be valid for an arbitrary interface polarization, and up to 2nd\n order in the transmission probabilities and spin-mixing angles of the interface. Arguments Type Intent Optional Attributes Name class( spinactive ), intent(in) :: this type(nambu), intent(in) :: G0 Propagator matrices type(nambu), intent(in) :: G1 Propagator matrices Return Value type(nambu) Matrix current procedure, public :: kinetic_current => spinactive_kinetic_current private pure subroutine spinactive_kinetic_current(this, G0, G1, C0, C1) Calculate the kinetic boundary coefficients at an interface with spin-active properties.\n These can be used to calculate the generalized current according to J = C₀H₀ - C₁H₁. Arguments Type Intent Optional Attributes Name class( spinactive ), intent(in) :: this type( propagator ), intent(in) :: G0 Propagator (this  side) type( propagator ), intent(in) :: G1 Propagator (other side) complex(kind=wp), intent(out), dimension(0:7,0:7) :: C0 Boundary coefficient (this  side) complex(kind=wp), intent(out), dimension(0:7,0:7) :: C1 Boundary coefficient (other side) procedure, public :: update_prehook => spinactive_update_prehook private impure subroutine spinactive_update_prehook(this) Updates the internal variables associated with spin-active interfaces. Arguments Type Intent Optional Attributes Name class( spinactive ), intent(inout) :: this","tags":"","loc":"type/spinactive.html","title":"spinactive – ​ "},{"text":"type, public, extends( ferromagnet ) :: superconductor Contents Variables length thouless scattering transparent_a transparent_b phaselock equilibrium transverse voltage temperature spinvoltage spintemperature spinaxis energy location propagator backup density supercurrent lossycurrent accumulation magnetization correlation order material_a material_b iteration selfconsistency scaling method control tolerance information difference type_string spinscattering spinorbit spinactive_a spinactive_b zeeman exchange gap_history gap_function gap_location Type-Bound Procedures update update_diffusion update_kinetic save load diffusion_equation_a diffusion_equation_b kinetic_equation_a kinetic_equation_b construct initialize diffusion_equation kinetic_equation update_gap update_boost update_prehook update_posthook gap conf Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) real(kind=wp), public, allocatable :: zeeman How easy the material is magnetized by spin accumulation real(kind=wp), public, allocatable :: exchange (:,:) Magnetic exchange field as a function of position complex(kind=wp), public, allocatable :: gap_history (:,:) Superconducting order parameter as a function of location (backup of previously calculated gaps on the location mesh) complex(kind=wp), public, allocatable :: gap_function (:) Superconducting order parameter as a function of location (relative to the zero-temperature gap of a bulk superconductor) real(kind=wp), public, allocatable :: gap_location (:) Location array for the gap function (required because we interpolate the gap to a higher resolution than the propagators) Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private impure subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \n equations for the equilibrium propagators, the kinetic equations for the \n nonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private impure subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public impure subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) private pure subroutine conductor_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: a type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) private pure subroutine conductor_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: b type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: construct => superconductor_construct Construct  propagators private impure subroutine superconductor_construct(this) Constructs a superconducting material that is initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: initialize => superconductor_initialize Initialize propagators private impure subroutine superconductor_initialize(this) Redefine the default initializer. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: diffusion_equation => superconductor_diffusion_equation Diffusion equation private pure subroutine superconductor_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(in) :: this type(propagator), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation => superconductor_kinetic_equation Kinetic equation private pure subroutine superconductor_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(in) :: this type(propagator), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: update_gap => superconductor_update_gap Calculate the superconducting order parameter private impure subroutine superconductor_update_gap(this) Interpolate the superconducting correlations Δ(z) to a higher resolution,\n to make the calculations more stable near strong ferromagnetic materials. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this Superconductor object procedure, public :: update_boost => superconductor_update_boost Boost the convergence of the order parameter (Steffensen's method) private impure subroutine superconductor_update_boost(this) Boost the convergence of the order parameter using Steffensen's method. Read more… Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: update_prehook => superconductor_update_prehook Update the internal variables before calculating the propagators private impure subroutine superconductor_update_prehook(this) Code to execute before running the update method of a class(superconductor) object. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: update_posthook => superconductor_update_posthook Update the superconducting order parameter from  the propagators private impure subroutine superconductor_update_posthook(this) Updates the superconducting order parameter based on the propagators of the system. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: gap => superconductor_gap Return the superconducting order parameter at a given position private pure function superconductor_gap(this, location) result(gap) Returns the superconducting order parameter at the given location. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(in) :: this real(kind=wp), intent(in) :: location Return Value complex(kind=wp) procedure, public :: conf => superconductor_conf Configure material parameters private impure subroutine superconductor_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val","tags":"","loc":"type/superconductor.html","title":"superconductor – ​ "},{"text":"type, public, extends( conductor ) :: ferromagnet Contents Variables length thouless scattering transparent_a transparent_b phaselock equilibrium transverse voltage temperature spinvoltage spintemperature spinaxis energy location propagator backup density supercurrent lossycurrent accumulation magnetization correlation order material_a material_b iteration selfconsistency scaling method control tolerance information difference type_string spinscattering spinorbit spinactive_a spinactive_b zeeman exchange Type-Bound Procedures update update_diffusion update_kinetic save load construct initialize update_posthook diffusion_equation_a diffusion_equation_b kinetic_equation_a kinetic_equation_b update_prehook diffusion_equation kinetic_equation conf Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) real(kind=wp), public, allocatable :: zeeman How easy the material is magnetized by spin accumulation real(kind=wp), public, allocatable :: exchange (:,:) Magnetic exchange field as a function of position Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private impure subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \n equations for the equilibrium propagators, the kinetic equations for the \n nonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private impure subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public impure subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: construct => conductor_construct Constructs the object private impure subroutine conductor_construct(this) Constructs a conductor object initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: initialize => conductor_initialize Initializes propagators private impure subroutine conductor_initialize(this) Define the default initializer. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates private impure subroutine conductor_update_posthook(this) Code to execute after running the update method of a class(conductor) object.\n In particular, this function calculates supercurrents, dissipative currents,\n accumulations, and density of states, and stores the results in the object. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) private pure subroutine conductor_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: a type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) private pure subroutine conductor_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: b type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: update_prehook => ferromagnet_update_prehook Code to execute before calculating the propagators private impure subroutine ferromagnet_update_prehook(this) Updates the exchange field terms in the diffusion equation. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(inout) :: this procedure, public :: diffusion_equation => ferromagnet_diffusion_equation Diffusion equation private pure subroutine ferromagnet_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(in) :: this type(propagator), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation => ferromagnet_kinetic_equation Kinetic equation private pure subroutine ferromagnet_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(in) :: this type(propagator), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: conf => ferromagnet_conf Configures material parameters private impure subroutine ferromagnet_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val","tags":"","loc":"type/ferromagnet.html","title":"ferromagnet – ​ "},{"text":"type, public, extends( conductor ) :: halfmetal Contents Variables length thouless scattering transparent_a transparent_b phaselock equilibrium transverse voltage temperature spinvoltage spintemperature spinaxis energy location propagator backup density supercurrent lossycurrent accumulation magnetization correlation order material_a material_b iteration selfconsistency scaling method control tolerance information difference type_string spinscattering spinorbit spinactive_a spinactive_b polarization Type-Bound Procedures update update_diffusion update_kinetic save load construct initialize kinetic_equation kinetic_equation_a kinetic_equation_b conf diffusion_equation diffusion_equation_a diffusion_equation_b update_prehook update_posthook update_density Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) real(kind=wp), public :: polarization = 0.0_wp Spin-polarization of the ferromagnet Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private impure subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \n equations for the equilibrium propagators, the kinetic equations for the \n nonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private impure subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public impure subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: construct => conductor_construct Constructs the object private impure subroutine conductor_construct(this) Constructs a conductor object initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: initialize => conductor_initialize Initializes propagators private impure subroutine conductor_initialize(this) Define the default initializer. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation private pure subroutine conductor_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: conf => halfmetal_conf Configures the material parameters private impure subroutine halfmetal_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val procedure, public :: diffusion_equation => halfmetal_diffusion_equation Defines the Usadel diffusion equation private pure subroutine halfmetal_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second-derivatives\n of the Riccati parameters at an energy e and a position z. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(in) :: this type(propagator), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: diffusion_equation_a => halfmetal_diffusion_equation_a Boundary condition at the left  interface private pure subroutine halfmetal_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: a type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: diffusion_equation_b => halfmetal_diffusion_equation_b Boundary condition at the right interface private pure subroutine halfmetal_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: b type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: update_prehook => halfmetal_update_prehook Code to execute before calculating the propagators private impure subroutine halfmetal_update_prehook(this) Code to execute before running the update method of a class(halfmetal) object. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this procedure, public :: update_posthook => halfmetal_update_posthook Code to execute after  calculating the propagators private impure subroutine halfmetal_update_posthook(this) Code to execute after running the update method of a class(halfmetal) object. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this procedure, public :: update_density => halfmetal_update_density Calculates the density of states private pure subroutine halfmetal_update_density(this) Calculate the density of states in the halfmetal. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this","tags":"","loc":"type/halfmetal.html","title":"halfmetal – ​ "},{"text":"type, public, extends( material ) :: conductor Contents Variables length thouless scattering transparent_a transparent_b phaselock equilibrium transverse voltage temperature spinvoltage spintemperature spinaxis energy location propagator backup density supercurrent lossycurrent accumulation magnetization correlation order material_a material_b iteration selfconsistency scaling method control tolerance information difference type_string spinscattering spinorbit spinactive_a spinactive_b Type-Bound Procedures update update_diffusion update_kinetic save load construct initialize update_prehook update_posthook diffusion_equation diffusion_equation_a diffusion_equation_b kinetic_equation kinetic_equation_a kinetic_equation_b conf Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private impure subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \n equations for the equilibrium propagators, the kinetic equations for the \n nonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private impure subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public impure subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: construct => conductor_construct Constructs the object private impure subroutine conductor_construct(this) Constructs a conductor object initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: initialize => conductor_initialize Initializes propagators private impure subroutine conductor_initialize(this) Define the default initializer. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: update_prehook => conductor_update_prehook Code to execute before updates private impure subroutine conductor_update_prehook(this) Code to execute before running the update method of a class(conductor) object. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates private impure subroutine conductor_update_posthook(this) Code to execute after running the update method of a class(conductor) object.\n In particular, this function calculates supercurrents, dissipative currents,\n accumulations, and density of states, and stores the results in the object. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: diffusion_equation => conductor_diffusion_equation Diffusion equation private pure subroutine conductor_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second-derivatives \n of the Riccati parameters at an energy e and position z. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) private pure subroutine conductor_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: a type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) private pure subroutine conductor_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: b type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation private pure subroutine conductor_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: conf => conductor_conf Configures material parameters private impure subroutine conductor_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val","tags":"","loc":"type/conductor.html","title":"conductor – ​ "},{"text":"type, public :: spinorbit Contents Variables material field Ax Ay Az A2 Axt Ayt Azt A2t Constructor spinorbit Type-Bound Procedures diffusion_equation diffusion_equation_a diffusion_equation_b update_prehook Components Type Visibility Attributes Name Initial class( material ), public, pointer :: material => null() Pointer to the material modelled by this instance type(spin), public, dimension(1:3) :: field Spin-orbit coupling field (SU(2) gauge field) type(spin), public :: Ax Spin-orbit coupling matrices (the components and square) type(spin), public :: Ay Spin-orbit coupling matrices (the components and square) type(spin), public :: Az Spin-orbit coupling matrices (the components and square) type(spin), public :: A2 Spin-orbit coupling matrices (the components and square) type(spin), public :: Axt Spin-orbit coupling matrices (tilde-conjugated versions) type(spin), public :: Ayt Spin-orbit coupling matrices (tilde-conjugated versions) type(spin), public :: Azt Spin-orbit coupling matrices (tilde-conjugated versions) type(spin), public :: A2t Spin-orbit coupling matrices (tilde-conjugated versions) Constructor public interface spinorbit public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit ) Type-Bound Procedures procedure, public :: diffusion_equation => spinorbit_diffusion_equation Diffusion equation private pure subroutine spinorbit_diffusion_equation(this, p) Calculate the spin-orbit coupling terms in the diffusion equation,\n and update the second derivatives of the Riccati parameters. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(in) :: this type(propagator), intent(inout) :: p procedure, public :: diffusion_equation_a => spinorbit_diffusion_equation_a Boundary condition (left) private pure subroutine spinorbit_diffusion_equation_a(this, p, r, rt) Calculate the spin-orbit coupling terms in the left boundary condition, and update the residuals. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(in), target :: this type(propagator), intent(in) :: p type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: diffusion_equation_b => spinorbit_diffusion_equation_b Boundary condition (right) private pure subroutine spinorbit_diffusion_equation_b(this, p, r, rt) Calculate the spin-orbit coupling terms in the right boundary condition, and update the residuals. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(in), target :: this type(propagator), intent(in) :: p type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure, public :: update_prehook => spinorbit_update_prehook Code to execute before updates private impure subroutine spinorbit_update_prehook(this) Updates the internal variables associated with spin-orbit coupling. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(inout) :: this","tags":"","loc":"type/spinorbit.html","title":"spinorbit – ​ "},{"text":"type, public, abstract :: material Contents Variables length thouless scattering transparent_a transparent_b phaselock equilibrium transverse voltage temperature spinvoltage spintemperature spinaxis energy location propagator backup density supercurrent lossycurrent accumulation magnetization correlation order material_a material_b iteration selfconsistency scaling method control tolerance information difference type_string Type-Bound Procedures construct initialize update_prehook update_posthook update update_diffusion update_kinetic diffusion_equation diffusion_equation_a diffusion_equation_b kinetic_equation kinetic_equation_a kinetic_equation_b conf save load Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material Type-Bound Procedures procedure(manipulate), public, deferred :: construct Construct  object subroutine manipulate(this) Prototype This interface is used for the deferred procedures construct, update_prehook, and update_posthook. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure(initialize), public, deferred :: initialize Initialize object subroutine initialize(this) Prototype This interface is used for the deferred procedure initialize. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure(manipulate), public, deferred :: update_prehook Executed before update subroutine manipulate(this) Prototype This interface is used for the deferred procedures construct, update_prehook, and update_posthook. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure(manipulate), public, deferred :: update_posthook Executed after  update subroutine manipulate(this) Prototype This interface is used for the deferred procedures construct, update_prehook, and update_posthook. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: update => material_update Calculate propagators private impure subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \n equations for the equilibrium propagators, the kinetic equations for the \n nonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure(diffusion_equation), public, deferred :: diffusion_equation Diffusion equation pure subroutine diffusion_equation(this, p, e, z) Prototype This interface is used for the deferred procedure diffusion_equation. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type(propagator), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure(diffusion_equation_a), public, deferred :: diffusion_equation_a Boundary condition (left) pure subroutine diffusion_equation_a(this, p, a, r, rt) Prototype This interface is used for the deferred procedure diffusion_equation_a. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: a type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure(diffusion_equation_b), public, deferred :: diffusion_equation_b Boundary condition (right) pure subroutine diffusion_equation_b(this, p, b, r, rt) Prototype This interface is used for the deferred procedure diffusion_equation_b. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type(propagator), intent(in) :: p type(propagator), intent(in) :: b type(spin), intent(inout) :: r type(spin), intent(inout) :: rt procedure(kinetic_equation), public, deferred :: kinetic_equation Kinetic equation pure subroutine kinetic_equation(this, Gp, R, z) Prototype This interface is used for the deferred procedure kinetic_equation. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type(propagator), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure(kinetic_equation_a), public, deferred :: kinetic_equation_a Boundary condition (left) pure subroutine kinetic_equation_a(this, Gp, Ga, Cp, Ca) Prototype This interface is used for the deferred procedure kinetic_equation_a. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure(kinetic_equation_b), public, deferred :: kinetic_equation_b Boundary condition (right) pure subroutine kinetic_equation_b(this, Gp, Gb, Cp, Cb) Prototype This interface is used for the deferred procedure kinetic_equation_b. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type(propagator), intent(in) :: Gp type(propagator), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: conf => material_conf Configures material parameters public impure subroutine material_conf (this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val procedure, public :: save => material_save Saves the state of the material private impure subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public impure subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this","tags":"","loc":"type/material.html","title":"material – ​ "},{"text":"type, public :: spinscattering Contents Variables material nambuv depairing spinflip spinorbit Constructor spinscattering Type-Bound Procedures diffusion_equation kinetic_equation Components Type Visibility Attributes Name Initial class( material ), public, pointer :: material => null() Pointer to the material modelled by this instance type(nambu), public, dimension(0:7) :: nambuv Pauli matrices spanning the 4×4 Spin-Nambu space real(kind=wp), public :: depairing = 0.0_wp Orbital depairing coefficient real(kind=wp), public :: spinflip = 0.0_wp Spin-flip  scattering coefficient (1/8τΔ) real(kind=wp), public :: spinorbit = 0.0_wp Spin-orbit scattering coefficient (1/8τΔ) Constructor public interface spinscattering public impure function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering ) Type-Bound Procedures procedure, public :: diffusion_equation => spinscattering_diffusion_equation Diffusion equation private pure subroutine spinscattering_diffusion_equation(this, p) Calculate the spin-flip and spin-orbit scattering terms in the diffusion\n equation, and update the second derivatives of the Riccati parameters. Arguments Type Intent Optional Attributes Name class( spinscattering ), intent(in) :: this type(propagator), intent(inout) :: p procedure, public :: kinetic_equation => spinscattering_kinetic_equation Kinetic equation private pure subroutine spinscattering_kinetic_equation(this, Gp, R) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( spinscattering ), intent(in) :: this type(propagator), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R","tags":"","loc":"type/spinscattering.html","title":"spinscattering – ​ "},{"text":"public interface evaluate Public interface for various routines that evaluate mathematical expressions. Contents Module Procedures evaluate_scalar_value evaluate_scalar_field evaluate_vector_value evaluate_vector_field evaluate_logical_value evaluate_integer_value Module Procedures private impure subroutine evaluate_scalar_value(expression, value) This subroutine takes a scalar mathematical expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Scalar-valued mathematical expression real(kind=wp), intent(out) :: value Result of parsing the expression private impure subroutine evaluate_scalar_field(expression, domain, value) This subroutine takes a scalar mathematical function of some variable 'z' as input,  along \n with an array with discrete values for that variable 'z'.  It parses the provided function,\n evaluates it at each 'z'-value in the array, and then returns the discretized scalar field. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Scalar-valued function of position 'z' real(kind=wp), intent(in), dimension(:) :: domain Domain of the independent variable 'z' real(kind=wp), dimension(:), allocatable :: value Result of evaluating the field at each point of the domain private impure subroutine evaluate_vector_value(expression, value) This subroutine takes a vector mathematical expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Vector-valued mathematical expression real(kind=wp), intent(out), dimension(3) :: value Result of parsing the expression private impure subroutine evaluate_vector_field(expression, domain, value) This subroutine takes a vector mathematical function of some variable 'z' as input,  along \n with an array with discrete values for that variable 'z'.  It parses the provided function,\n evaluates it at each 'z'-value in the array, and then returns the discretized scalar field. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Vector-valued function of position 'z' real(kind=wp), intent(in), dimension(:) :: domain Domain of the independent variable 'z' real(kind=wp), dimension(:,:), allocatable :: value Result of evaluating the field at each point of the domain private impure subroutine evaluate_logical_value(expression, value) This subroutine takes a scalar logical expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Either the character 'T' or 'F' logical, intent(out) :: value Result of parsing the expression private impure subroutine evaluate_integer_value(expression, value) This subroutine takes a scalar integer expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression String containing an integer integer, intent(out) :: value Result of parsing the expression","tags":"","loc":"interface/evaluate.html","title":"evaluate – ​"},{"text":"public impure function input(file) result(unit) This function is used to open an input file for reading. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer Contents None","tags":"","loc":"proc/input.html","title":"input – ​"},{"text":"public impure function output(file) result(unit) This function is used to open an output file for writing. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer Contents None","tags":"","loc":"proc/output.html","title":"output – ​"},{"text":"public impure subroutine message(msg) This subroutine provides a way to report a status message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Contents None","tags":"","loc":"proc/message.html","title":"message – ​"},{"text":"public impure subroutine warning(msg) This subroutine provides a way to report a warning message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Contents None","tags":"","loc":"proc/warning.html","title":"warning – ​"},{"text":"public impure subroutine error(msg) This subroutine provides a way to report an error message and halt the program. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Contents None","tags":"","loc":"proc/error.html","title":"error – ​"},{"text":"public impure subroutine status_head(title) This subroutine is used to write boxed status messages to standard out;\n in particular, this routine writes out a boxed title with a timestamp. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Contents None","tags":"","loc":"proc/status_head.html","title":"status_head – ​"},{"text":"public impure subroutine status_body(title, value) This subroutine is used to write boxed status messages to standard out;\n in particular, this routine writes out the name and value of a variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title class(*), intent(in) :: value Contents None","tags":"","loc":"proc/status_body.html","title":"status_body – ​"},{"text":"public impure subroutine status_foot() This subroutine is used to write boxed status messages to standard out;\n in particular, this routine writes out the bottom edge of such a box. Arguments None Contents None","tags":"","loc":"proc/status_foot.html","title":"status_foot – ​"},{"text":"public impure subroutine status_box(title) This subroutine is used to write boxed status messages to standard out. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Contents None","tags":"","loc":"proc/status_box.html","title":"status_box – ​"},{"text":"public impure subroutine dump_arrays(filename, arrays, header) Uses iso_fortran_env This subroutine is used to dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header Contents None","tags":"","loc":"proc/dump_arrays.html","title":"dump_arrays – ​"},{"text":"public impure subroutine dump_scalar(filename, scalar) Uses iso_fortran_env This subroutine is used to dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar Contents None","tags":"","loc":"proc/dump_scalar.html","title":"dump_scalar – ​"},{"text":"public interface dump Public interface for functions that dump results to files Contents Module Procedures dump_arrays dump_scalar Module Procedures public impure subroutine dump_arrays (filename, arrays, header) This subroutine is used to dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header public impure subroutine dump_scalar (filename, scalar) This subroutine is used to dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar","tags":"","loc":"interface/dump.html","title":"dump – ​"},{"text":"public pure elemental function re(z) result(x) Returns the real part of a complex number z=x+iy. Note :\n   This function might be replaced by the structure\n   notation z%re when common compilers support it. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Real part Contents None","tags":"","loc":"proc/re.html","title":"re – ​"},{"text":"public pure elemental function im(z) result(y) Returns the imaginary part of a complex number z=x+iy. Note :\n   This function might be replaced by the structure\n   notation z%im when common compilers support it. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Imaginary part Contents None","tags":"","loc":"proc/im.html","title":"im – ​"},{"text":"public pure elemental function cx(x, y) result(z) Returns the complex number z=x+iy. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Real part real(kind=wp), intent(in), optional :: y Imaginary part Return Value complex(kind=wp) Complex number Contents None","tags":"","loc":"proc/cx.html","title":"cx – ​"},{"text":"public pure elemental function arg(z) result(t) Returns the complex argument θ of a complex number z=r·exp(iθ). Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Complex argument Contents None","tags":"","loc":"proc/arg.html","title":"arg – ​"},{"text":"public pure function unitvector(v) result(r) If the argument has a finite norm, then it will be rescaled to a unit\n vector. If that norm is zero, then a zero vector is returned instead. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v Vector Return Value real(kind=wp),\n  dimension(3) Unit vector Contents None","tags":"","loc":"proc/unitvector.html","title":"unitvector – ​"},{"text":"public pure function nonzero(v) result(r) Checks whether or not the argument has a finite norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v Vector Return Value logical Finite Contents None","tags":"","loc":"proc/nonzero.html","title":"nonzero – ​"},{"text":"public pure function mean_array_re(x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value Contents None","tags":"","loc":"proc/mean_array_re.html","title":"mean_array_re – ​"},{"text":"public pure function mean_array_cx(x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value Contents None","tags":"","loc":"proc/mean_array_cx.html","title":"mean_array_cx – ​"},{"text":"public pure function differentiate_array_re(x, y) result(r) This function calculates the numerical derivative of an array y with respect to x, using a central difference approximation\n at the interior points and forward/backward difference approximations at the exterior points. Note that since all the three\n approaches yield two-point approximations of the derivative, the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx Contents None","tags":"","loc":"proc/differentiate_array_re.html","title":"differentiate_array_re – ​"},{"text":"public pure function differentiate_array_cx(x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx Contents None","tags":"","loc":"proc/differentiate_array_cx.html","title":"differentiate_array_cx – ​"},{"text":"public pure function integrate_array_re(x, y) result(r) This function calculates the integral of an array y with respect to x using a trapezoid\n approximation. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_array_re.html","title":"integrate_array_re – ​"},{"text":"public pure function integrate_array_cx(x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_array_cx.html","title":"integrate_array_cx – ​"},{"text":"public function integrate_range_re(x, y, a, b) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on\n discrete numerical data, and subsequently evaluates the integral of the interpolation in the\n range (a,b). Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_range_re.html","title":"integrate_range_re – ​"},{"text":"public function integrate_range_cx(x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_range_cx.html","title":"integrate_range_cx – ​"},{"text":"public function interpolate_array_re(x, y, p) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on discrete numerical data,\n and evaluates the interpolation at points p. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation result y(p) Contents None","tags":"","loc":"proc/interpolate_array_re.html","title":"interpolate_array_re – ​"},{"text":"public function interpolate_array_cx(x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation result y(p) Contents None","tags":"","loc":"proc/interpolate_array_cx.html","title":"interpolate_array_cx – ​"},{"text":"public function interpolate_point_re(x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp) Interpolation result y(p) Contents None","tags":"","loc":"proc/interpolate_point_re.html","title":"interpolate_point_re – ​"},{"text":"public function interpolate_point_cx(x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value complex(kind=wp) Interpolation result y(p) Contents None","tags":"","loc":"proc/interpolate_point_cx.html","title":"interpolate_point_cx – ​"},{"text":"public pure function interpolate_point_matrix_re(x, y, p) result(r) Perform a Piecewise Cubic Hermitian Interpolation of a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:,:,:) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp),\n  dimension(size(y,1),size(y,2)) Interpolation result y(p) Contents None","tags":"","loc":"proc/interpolate_point_matrix_re.html","title":"interpolate_point_matrix_re – ​"},{"text":"public pure subroutine linspace_array_re(array, first, last) Populates an existing array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element Contents None","tags":"","loc":"proc/linspace_array_re.html","title":"linspace_array_re – ​"},{"text":"public interface propagator Contents Module Procedures propagator_construct_vacuum propagator_construct_riccati propagator_construct_bcs Module Procedures private pure function propagator_construct_vacuum() result(this) Construct a vacuum propagator, i.e. a propagator which satisfies G=0. Arguments None Return Value type( propagator ) Constructed object private pure function propagator_construct_riccati(g, gt, dg, dgt) result(this) Construct an arbitrary state by explicitly providing the Riccati parameters.\n Unspecified Riccati parameters default to zero due to the spin constructors.\n The distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: g Riccati parameter γ type( spin ), intent(in) :: gt Riccati parameter γ~ type( spin ), intent(in), optional :: dg Riccati parameter ∇γ type( spin ), intent(in), optional :: dgt Riccati parameter ∇γ~ Return Value type( propagator ) Constructed object private pure function propagator_construct_bcs(energy, gap) result(this) Constructs a state corresponding to a BCS superconductor at some given energy,\n which may have an imaginary term representing inelastic scattering. The second\n argument 'gap' is used to provide the superconducting order parameter Δ.\n The distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: energy Quasiparticle energy (including inelastic scattering contribution) complex(kind=wp), intent(in) :: gap Superconducting order parameter (including superconducting phase) Return Value type( propagator ) Constructed object","tags":"","loc":"interface/propagator.html","title":"propagator – ​"},{"text":"public interface inverse Matrix inverse Contents Module Procedures nambu_inv Module Procedures private pure function nambu_inv(this) result(r) Calculate the inverse of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu )","tags":"","loc":"interface/inverse.html","title":"inverse – ​"},{"text":"public interface trace Matrix trace Contents Module Procedures nambu_trace Module Procedures private pure elemental function nambu_trace(this) result(r) Calculate the trace of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value complex(kind=wp)","tags":"","loc":"interface/trace.html","title":"trace – ​"},{"text":"public interface sum Matrix sum Contents Module Procedures nambu_sum Module Procedures private pure function nambu_sum(this) result(r) Calculate the sum of an array of nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this (:) Return Value type( nambu )","tags":"","loc":"interface/sum.html","title":"sum – ​"},{"text":"public interface conjg Complex conjugation Contents Module Procedures nambu_conjg Module Procedures private pure elemental function nambu_conjg(this) result(r) Calculate the complex conjugate of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu )","tags":"","loc":"interface/conjg.html","title":"conjg – ​"},{"text":"public interface nambuv Construct basis matrices Contents Module Procedures nambuv_scalar nambuv_vector Module Procedures private pure function nambuv_scalar(n) result(r) Constructs basis matrix number n in spin-nambu space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value type( nambu ) private pure function nambuv_vector(v) result(r) Constructs a matrix representation of a vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:3) :: v Return Value type( nambu )","tags":"","loc":"interface/nambuv.html","title":"nambuv – ​"},{"text":"public pure function identity(n) result(R) Constructs an n×n identity matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Matrix dimension Return Value real(kind=wp),\n  dimension(n,n) Identity matrix [n×n] Contents None","tags":"","loc":"proc/identity.html","title":"identity – ​"},{"text":"public pure function matrix_inverse_re(A) result(R) Wrapper for matrix_inverse_cx that allows the procedure to be used for real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹ Contents None","tags":"","loc":"proc/matrix_inverse_re.html","title":"matrix_inverse_re – ​"},{"text":"public pure function matrix_inverse_cx(A) result(R) Invert a square n×n matrix using Gauss-Jordan elimination with partial pivoting.\n In the special case n=2, the inverse is evaluated using a cofactoring algorithm.\n [This implementation is based on Algorithm #2 in \"Efficient matrix inversion via \n Gauss-Jordan elimination and its parallelization\" by E.S. Quintana et al. (1998)] Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹ Contents None","tags":"","loc":"proc/matrix_inverse_cx.html","title":"matrix_inverse_cx – ​"},{"text":"public pure function matrix_trace(A) result(r) Calculate the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A) Contents None","tags":"","loc":"proc/matrix_trace.html","title":"matrix_trace – ​"},{"text":"public pure function commutator(A, B) result(R) Calculate the commutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A,1),size(A,1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Commutator R = [A,B] Contents None","tags":"","loc":"proc/commutator.html","title":"commutator – ​"},{"text":"public pure function anticommutator(A, B) result(R) Calculate the anticommutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A,1),size(A,1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Anticommutator R = {A,B} Contents None","tags":"","loc":"proc/anticommutator.html","title":"anticommutator – ​"},{"text":"public pure function vector_diag(A) result(r) Extract the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A,1),size(A,2))) r = Diag(A) Contents None","tags":"","loc":"proc/vector_diag.html","title":"vector_diag – ​"},{"text":"public pure function matrix_diag(A, B) result(R) Construct a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:,:) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A,1)+size(B,1), size(A,2)+size(B,2)) R = Diag(A,B) Contents None","tags":"","loc":"proc/matrix_diag.html","title":"matrix_diag – ​"},{"text":"public interface inverse Matrix inverse Contents Module Procedures spin_inv Module Procedures private pure function spin_inv(this) result(r) Calculate the inverse of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin )","tags":"","loc":"interface/inverse~2.html","title":"inverse – ​"},{"text":"public interface trace Matrix trace Contents Module Procedures spin_trace Module Procedures private pure elemental function spin_trace(this) result(r) Calculate the trace of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value complex(kind=wp)","tags":"","loc":"interface/trace~2.html","title":"trace – ​"},{"text":"public interface sum Matrix sum Contents Module Procedures spin_sum Module Procedures private pure function spin_sum(this) result(r) Calculate the sum of an array of spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this (:) Return Value type( spin )","tags":"","loc":"interface/sum~2.html","title":"sum – ​"},{"text":"public interface conjg Complex conjugation Contents Module Procedures spin_conjg Module Procedures private pure elemental function spin_conjg(this) result(r) Calculate the complex conjugate of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin )","tags":"","loc":"interface/conjg~2.html","title":"conjg – ​"},{"text":"public interface norm2 Matrix norm Contents Module Procedures spin_norm Module Procedures private pure elemental function spin_norm(this) result(r) Calculate the Frobenius norm of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value real(kind=wp)","tags":"","loc":"interface/norm2.html","title":"norm2 – ​"},{"text":"public interface trace Public interface for functions that calculate a matrix trace. Contents Module Procedures matrix_trace Module Procedures public pure function matrix_trace (A) result(r) Calculate the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A)","tags":"","loc":"interface/trace~3.html","title":"trace – ​"},{"text":"public interface inverse Public interface for functions that calculate a matrix inverse. Contents Module Procedures matrix_inverse_re matrix_inverse_cx Module Procedures public pure function matrix_inverse_re (A) result(R) Wrapper for matrix_inverse_cx that allows the procedure to be used for real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹ public pure function matrix_inverse_cx (A) result(R) Invert a square n×n matrix using Gauss-Jordan elimination with partial pivoting.\n In the special case n=2, the inverse is evaluated using a cofactoring algorithm.\n [This implementation is based on Algorithm #2 in \"Efficient matrix inversion via \n Gauss-Jordan elimination and its parallelization\" by E.S. Quintana et al. (1998)] Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹","tags":"","loc":"interface/inverse~3.html","title":"inverse – ​"},{"text":"public interface diag Public interface for functions that deal with matrix diagonals. Contents Module Procedures matrix_diag vector_diag Module Procedures public pure function matrix_diag (A, B) result(R) Construct a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:,:) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A,1)+size(B,1), size(A,2)+size(B,2)) R = Diag(A,B) public pure function vector_diag (A) result(r) Extract the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A,1),size(A,2))) r = Diag(A)","tags":"","loc":"interface/diag.html","title":"diag – ​"},{"text":"public interface mean Public interface for routines that calculate the mean value. Contents Module Procedures mean_array_re mean_array_cx Module Procedures public pure function mean_array_re (x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value public pure function mean_array_cx (x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value","tags":"","loc":"interface/mean.html","title":"mean – ​"},{"text":"public interface differentiate Public interface for various differentiation routines. Contents Module Procedures differentiate_array_re differentiate_array_cx Module Procedures public pure function differentiate_array_re (x, y) result(r) This function calculates the numerical derivative of an array y with respect to x, using a central difference approximation\n at the interior points and forward/backward difference approximations at the exterior points. Note that since all the three\n approaches yield two-point approximations of the derivative, the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function differentiate_array_cx (x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx","tags":"","loc":"interface/differentiate.html","title":"differentiate – ​"},{"text":"public interface integrate Public interface for various integration routines. Contents Module Procedures integrate_array_re integrate_array_cx integrate_range_re integrate_range_cx Module Procedures public pure function integrate_array_re (x, y) result(r) This function calculates the integral of an array y with respect to x using a trapezoid\n approximation. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx public pure function integrate_array_cx (x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx public function integrate_range_re (x, y, a, b) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on\n discrete numerical data, and subsequently evaluates the integral of the interpolation in the\n range (a,b). Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx public function integrate_range_cx (x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx","tags":"","loc":"interface/integrate.html","title":"integrate – ​"},{"text":"public interface interpolate Public interface for various interpolation routines. Contents Module Procedures interpolate_point_re interpolate_point_cx interpolate_array_re interpolate_array_cx interpolate_point_matrix_re Module Procedures public function interpolate_point_re (x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp) Interpolation result y(p) public function interpolate_point_cx (x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value complex(kind=wp) Interpolation result y(p) public function interpolate_array_re (x, y, p) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on discrete numerical data,\n and evaluates the interpolation at points p. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation result y(p) public function interpolate_array_cx (x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation result y(p) public pure function interpolate_point_matrix_re (x, y, p) result(r) Perform a Piecewise Cubic Hermitian Interpolation of a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:,:,:) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp),\n  dimension(size(y,1),size(y,2)) Interpolation result y(p)","tags":"","loc":"interface/interpolate.html","title":"interpolate – ​"},{"text":"public interface linspace Public interface for routines that initialize arrays. Contents Module Procedures linspace_array_re Module Procedures public pure subroutine linspace_array_re (array, first, last) Populates an existing array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element","tags":"","loc":"interface/linspace.html","title":"linspace – ​"},{"text":"public interface structure Contents Module Procedures structure_construct Module Procedures private impure function structure_construct() result(this) Constructs a multilayer stack from a configuration file. Arguments None Return Value type( structure )","tags":"","loc":"interface/structure.html","title":"structure – ​"},{"text":"public function spinorbit_construct(parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit ) Contents None","tags":"","loc":"proc/spinorbit_construct.html","title":"spinorbit_construct – ​"},{"text":"public interface spinorbit Contents Module Procedures spinorbit_construct Module Procedures public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit )","tags":"","loc":"interface/spinorbit.html","title":"spinorbit – ​"},{"text":"public impure subroutine material_conf(this, key, val) Uses evaluate_m Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val Contents None","tags":"","loc":"proc/material_conf.html","title":"material_conf – ​"},{"text":"public impure subroutine material_load(this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Contents None","tags":"","loc":"proc/material_load.html","title":"material_load – ​"},{"text":"public impure function spinscattering_construct(parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering ) Contents None","tags":"","loc":"proc/spinscattering_construct.html","title":"spinscattering_construct – ​"},{"text":"public interface spinscattering Contents Module Procedures spinscattering_construct Module Procedures public impure function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering )","tags":"","loc":"interface/spinscattering.html","title":"spinscattering – ​"},{"text":"impure subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook.html","title":"prehook – ​"},{"text":"impure subroutine posthook() Arguments None Contents None","tags":"","loc":"proc/posthook.html","title":"posthook – ​"},{"text":"impure subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize.html","title":"finalize – ​"},{"text":"impure subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook~2.html","title":"prehook – ​"},{"text":"impure subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~2.html","title":"finalize – ​"},{"text":"impure subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~3.html","title":"finalize – ​"},{"text":"impure subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook~3.html","title":"prehook – ​"},{"text":"impure subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~4.html","title":"finalize – ​"},{"text":"impure subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook~4.html","title":"prehook – ​"},{"text":"impure subroutine posthook() Arguments None Contents None","tags":"","loc":"proc/posthook~2.html","title":"posthook – ​"},{"text":"impure subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~5.html","title":"finalize – ​"},{"text":"This file defines functions that perform some common matrix operations. Uses math_m stdio_m Contents Interfaces evaluate Interfaces public interface evaluate Public interface for various routines that evaluate mathematical expressions. private impure subroutine evaluate_scalar_value(expression, value) This subroutine takes a scalar mathematical expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Scalar-valued mathematical expression real(kind=wp), intent(out) :: value Result of parsing the expression private impure subroutine evaluate_scalar_field(expression, domain, value) This subroutine takes a scalar mathematical function of some variable 'z' as input,  along \n with an array with discrete values for that variable 'z'.  It parses the provided function,\n evaluates it at each 'z'-value in the array, and then returns the discretized scalar field. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Scalar-valued function of position 'z' real(kind=wp), intent(in), dimension(:) :: domain Domain of the independent variable 'z' real(kind=wp), dimension(:), allocatable :: value Result of evaluating the field at each point of the domain private impure subroutine evaluate_vector_value(expression, value) This subroutine takes a vector mathematical expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Vector-valued mathematical expression real(kind=wp), intent(out), dimension(3) :: value Result of parsing the expression private impure subroutine evaluate_vector_field(expression, domain, value) This subroutine takes a vector mathematical function of some variable 'z' as input,  along \n with an array with discrete values for that variable 'z'.  It parses the provided function,\n evaluates it at each 'z'-value in the array, and then returns the discretized scalar field. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Vector-valued function of position 'z' real(kind=wp), intent(in), dimension(:) :: domain Domain of the independent variable 'z' real(kind=wp), dimension(:,:), allocatable :: value Result of evaluating the field at each point of the domain private impure subroutine evaluate_logical_value(expression, value) This subroutine takes a scalar logical expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression Either the character 'T' or 'F' logical, intent(out) :: value Result of parsing the expression private impure subroutine evaluate_integer_value(expression, value) This subroutine takes a scalar integer expression as input, and returns the value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expression String containing an integer integer, intent(out) :: value Result of parsing the expression","tags":"Foundation","loc":"module/evaluate_m.html","title":"evaluate_m – ​"},{"text":"This file renames the ISO input/output units to the standard UNIX names, \n defines the ANSI escape codes for colored output, and defines a number of \n auxiliary subroutines for e.g. writing out error and warning messages. Uses iso_fortran_env Contents Variables stdin stdout stderr color_none color_red color_green color_yellow color_blue color_purple color_cyan color_white Interfaces dump Functions input output Subroutines message warning error status_head status_body status_foot status_box dump_arrays dump_scalar Variables Type Visibility Attributes Name Initial integer, public :: stdin = input_unit integer, public :: stdout = output_unit integer, public :: stderr = error_unit character(len=*), public, parameter :: color_none = '\u001b[00m' character(len=*), public, parameter :: color_red = '\u001b[31m' character(len=*), public, parameter :: color_green = '\u001b[32m' character(len=*), public, parameter :: color_yellow = '\u001b[33m' character(len=*), public, parameter :: color_blue = '\u001b[34m' character(len=*), public, parameter :: color_purple = '\u001b[35m' character(len=*), public, parameter :: color_cyan = '\u001b[36m' character(len=*), public, parameter :: color_white = '\u001b[37m' Interfaces public interface dump Public interface for functions that dump results to files public impure subroutine dump_arrays (filename, arrays, header) This subroutine is used to dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header public impure subroutine dump_scalar (filename, scalar) This subroutine is used to dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar Functions public impure function input (file) result(unit) This function is used to open an input file for reading. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer public impure function output (file) result(unit) This function is used to open an output file for writing. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer Subroutines public impure subroutine message (msg) This subroutine provides a way to report a status message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public impure subroutine warning (msg) This subroutine provides a way to report a warning message. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public impure subroutine error (msg) This subroutine provides a way to report an error message and halt the program. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public impure subroutine status_head (title) This subroutine is used to write boxed status messages to standard out;\n in particular, this routine writes out a boxed title with a timestamp. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title public impure subroutine status_body (title, value) This subroutine is used to write boxed status messages to standard out;\n in particular, this routine writes out the name and value of a variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title class(*), intent(in) :: value public impure subroutine status_foot () This subroutine is used to write boxed status messages to standard out;\n in particular, this routine writes out the bottom edge of such a box. Arguments None public impure subroutine status_box (title) This subroutine is used to write boxed status messages to standard out. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title public impure subroutine dump_arrays (filename, arrays, header) This subroutine is used to dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header public impure subroutine dump_scalar (filename, scalar) This subroutine is used to dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar","tags":"System","loc":"module/stdio_m.html","title":"stdio_m – ​"},{"text":"This file provides a common interface to a library of mathematical objects\n that can be useful for modelling materials in condensed matter physics. Uses math_m spin_m nambu_m propagator_m Contents None","tags":"Foundation","loc":"module/condmat_m.html","title":"condmat_m – ​"},{"text":"This file defines a module containing the machine size of single-precision, double-precision, and quadruple-precision\n floating point numbers; to declare the floating point precision of a variable, use real(sp), real(dp), or real(qp) as\n the type of the variable. It also defines the working-precision, which will be the default kind for module procedures.\n As for module procedures, this library defines some common utility functions for working with e.g. complex numbers. Uses iso_fortran_env Contents Variables sp dp qp wp inf eps pi Functions re im cx arg unitvector nonzero Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = real32 Single precision integer, public, parameter :: dp = real64 Double precision integer, public, parameter :: qp = real128 Quadruple precision integer, public, parameter :: wp = dp Working precision real(kind=wp), public, parameter :: inf = huge(1.0_wp) Numerical infinity real(kind=wp), public, parameter :: eps = epsilon(1.0_wp) Numerical infinitesimal real(kind=wp), public, parameter :: pi = atan(1.0_wp)*4.0_wp Circle constant Functions public pure elemental function re (z) result(x) Returns the real part of a complex number z=x+iy. Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Real part public pure elemental function im (z) result(y) Returns the imaginary part of a complex number z=x+iy. Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Imaginary part public pure elemental function cx (x, y) result(z) Returns the complex number z=x+iy. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Real part real(kind=wp), intent(in), optional :: y Imaginary part Return Value complex(kind=wp) Complex number public pure elemental function arg (z) result(t) Returns the complex argument θ of a complex number z=r·exp(iθ). Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Complex argument public pure function unitvector (v) result(r) If the argument has a finite norm, then it will be rescaled to a unit\n vector. If that norm is zero, then a zero vector is returned instead. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v Vector Return Value real(kind=wp),\n  dimension(3) Unit vector public pure function nonzero (v) result(r) Checks whether or not the argument has a finite norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v Vector Return Value logical Finite","tags":"Foundation","loc":"module/basic_m.html","title":"basic_m – ​"},{"text":"This file defines functions that perform some common calculus operations. Uses basic_m Contents Functions mean_array_re mean_array_cx differentiate_array_re differentiate_array_cx integrate_array_re integrate_array_cx integrate_range_re integrate_range_cx interpolate_array_re interpolate_array_cx interpolate_point_re interpolate_point_cx interpolate_point_matrix_re Subroutines linspace_array_re Functions public pure function mean_array_re (x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value public pure function mean_array_cx (x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value public pure function differentiate_array_re (x, y) result(r) This function calculates the numerical derivative of an array y with respect to x, using a central difference approximation\n at the interior points and forward/backward difference approximations at the exterior points. Note that since all the three\n approaches yield two-point approximations of the derivative, the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function differentiate_array_cx (x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function integrate_array_re (x, y) result(r) This function calculates the integral of an array y with respect to x using a trapezoid\n approximation. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx public pure function integrate_array_cx (x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx public function integrate_range_re (x, y, a, b) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on\n discrete numerical data, and subsequently evaluates the integral of the interpolation in the\n range (a,b). Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx public function integrate_range_cx (x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx public function interpolate_array_re (x, y, p) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on discrete numerical data,\n and evaluates the interpolation at points p. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation result y(p) public function interpolate_array_cx (x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation result y(p) public function interpolate_point_re (x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp) Interpolation result y(p) public function interpolate_point_cx (x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value complex(kind=wp) Interpolation result y(p) public pure function interpolate_point_matrix_re (x, y, p) result(r) Perform a Piecewise Cubic Hermitian Interpolation of a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:,:,:) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp),\n  dimension(size(y,1),size(y,2)) Interpolation result y(p) Subroutines public pure subroutine linspace_array_re (array, first, last) Populates an existing array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element","tags":"Foundation","loc":"module/calculus_m.html","title":"calculus_m – ​"},{"text":"This module defines the data type 'propagator', which represents the propagator at a given position and energy. \n The equilibrium propagators (retarded and advanced) are stored internally using the Riccati parameters γ and γ~\n and their derivatives, while the nonequilibrium propagator (Keldysh) is represented by taking the traces of the\n distribution function and its derivatives. These quantities are together sufficient to reconstruct the full 8×8\n propagator and its derivatives, and can be used to calculate associated physical quantities such as the density\n of states, charge currents, spin currents, heat currents, spin-heat currents, and various accumulation effects. Uses math_m spin_m nambu_m Contents Interfaces propagator Derived Types propagator Interfaces public interface propagator private pure function propagator_construct_vacuum() result(this) Construct a vacuum propagator, i.e. a propagator which satisfies G=0. Arguments None Return Value type( propagator ) Constructed object private pure function propagator_construct_riccati(g, gt, dg, dgt) result(this) Construct an arbitrary state by explicitly providing the Riccati parameters.\n Unspecified Riccati parameters default to zero due to the spin constructors.\n The distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: g Riccati parameter γ type( spin ), intent(in) :: gt Riccati parameter γ~ type( spin ), intent(in), optional :: dg Riccati parameter ∇γ type( spin ), intent(in), optional :: dgt Riccati parameter ∇γ~ Return Value type( propagator ) Constructed object private pure function propagator_construct_bcs(energy, gap) result(this) Constructs a state corresponding to a BCS superconductor at some given energy,\n which may have an imaginary term representing inelastic scattering. The second\n argument 'gap' is used to provide the superconducting order parameter Δ.\n The distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: energy Quasiparticle energy (including inelastic scattering contribution) complex(kind=wp), intent(in) :: gap Superconducting order parameter (including superconducting phase) Return Value type( propagator ) Constructed object Derived Types type, public :: propagator Components Type Visibility Attributes Name Initial type( spin ), public :: g Riccati parameter γ type( spin ), public :: gt Riccati parameter γ~ type( spin ), public :: dg Riccati parameter ∇γ type( spin ), public :: dgt Riccati parameter ∇γ~ type( spin ), public :: d2g Riccati parameter ∇²γ type( spin ), public :: d2gt Riccati parameter ∇²γ~ type( spin ), public :: N Riccati normalization N type( spin ), public :: Nt Riccati normalization N~ real(kind=wp), public, dimension(0:7) :: h = [1, 0, 0, 0, 0, 0, 0, 0] Distribution-trace H real(kind=wp), public, dimension(0:7) :: dh = [0, 0, 0, 0, 0, 0, 0, 0] Distribution-trace ∇H real(kind=wp), public, dimension(0:7) :: d2h = [0, 0, 0, 0, 0, 0, 0, 0] Distribution-trace ∇²H Constructor private pure function propagator_construct_vacuum () Construct a vacuum propagator, i.e. a propagator which satisfies G=0. private pure function propagator_construct_riccati (g, gt, dg, dgt) Construct an arbitrary state by explicitly providing the Riccati parameters.\n Unspecified Riccati parameters default to zero due to the spin constructors.\n The distribution function defaults to equilibrium at zero temperature. private pure function propagator_construct_bcs (energy, gap) Constructs a state corresponding to a BCS superconductor at some given energy,\n which may have an imaginary term representing inelastic scattering. The second\n argument 'gap' is used to provide the superconducting order parameter Δ.\n The distribution function defaults to equilibrium at zero temperature. Type-Bound Procedures procedure, public :: retarded => propagator_retarded Retarded propagator G&#94;R procedure, public :: retarded_gradient => propagator_retarded_gradient Retarded propagator ∇G&#94;R procedure, public :: retarded_laplacian => propagator_retarded_laplacian Retarded propagator ∇²G&#94;R procedure, public :: advanced => propagator_advanced Advanced propagator G&#94;A procedure, public :: advanced_gradient => propagator_advanced_gradient Advanced propagator ∇G&#94;A procedure, public :: advanced_laplacian => propagator_advanced_laplacian Advanced propagator ∇²G&#94;A procedure, public :: keldysh => propagator_keldysh Keldysh propagator G&#94;K procedure, public :: keldysh_gradient => propagator_keldysh_gradient Keldysh propagator ∇G&#94;K procedure, public :: distribution => propagator_distribution Distribution matrix H procedure, public :: distribution_gradient => propagator_distribution_gradient Distribution matrix ∇H procedure, public :: dissipation => propagator_dissipation Dissipation matrix M procedure, public :: dissipation_gradient => propagator_dissipation_gradient Dissipation matrix ∇M procedure, public :: condensate => propagator_condensate Condensate matrix Q procedure, public :: condensate_gradient => propagator_condensate_gradient Condensate matrix ∇Q procedure, public :: selfenergy1 => propagator_selfenergy1 Selfenergy matrix R₁ procedure, public :: selfenergy2 => propagator_selfenergy2 Selfenergy matrix R₂ procedure, public :: supercurrent => propagator_supercurrent Spectral supercurrents procedure, public :: lossycurrent => propagator_lossycurrent Spectral dissipative currents procedure, public :: accumulation => propagator_accumulation Spectral accumulations procedure, public :: correlation => propagator_correlation Spectral correlations procedure, public :: density => propagator_density Spin-resolved density of states procedure, public :: save => propagator_save Export Riccati parameters procedure, public :: load => propagator_load Import Riccati parameters","tags":"Foundation","loc":"module/propagator_m.html","title":"propagator_m – ​"},{"text":"This module defines the data type 'nambu', which represents 4×4 complex matrices in spin and Nambu space. The module\n overloads arithmetic operators to work with the new type, and defines and exports the Pauli matrices as constants. Uses math_m spin_m Contents Interfaces inverse trace sum conjg nambuv Derived Types nambu Interfaces public interface inverse Matrix inverse private pure function nambu_inv(this) result(r) Calculate the inverse of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu ) public interface trace Matrix trace private pure elemental function nambu_trace(this) result(r) Calculate the trace of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value complex(kind=wp) public interface sum Matrix sum private pure function nambu_sum(this) result(r) Calculate the sum of an array of nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this (:) Return Value type( nambu ) public interface conjg Complex conjugation private pure elemental function nambu_conjg(this) result(r) Calculate the complex conjugate of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu ) public interface nambuv Construct basis matrices private pure function nambuv_scalar(n) result(r) Constructs basis matrix number n in spin-nambu space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value type( nambu ) private pure function nambuv_vector(v) result(r) Constructs a matrix representation of a vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:3) :: v Return Value type( nambu ) Derived Types type, public :: nambu Components Type Visibility Attributes Name Initial complex(kind=wp), public :: matrix (4,4) = 0.0_wp Encapsulate a spin and Nambu space matrix Type-Bound Procedures generic, public :: nambu => cons_rscalar, cons_cscalar, cons_cmatrix, cons_nambu generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assl_cmatrix generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_nambu generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_nambu generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_nambu generic, public :: operator(/) => divr_rscalar, divr_cscalar generic, public :: operator(**) => expr_iscalar","tags":"Foundation","loc":"module/nambu_m.html","title":"nambu_m – ​"},{"text":"This file defines functions that perform some common matrix operations. Uses basic_m Contents Functions identity matrix_inverse_re matrix_inverse_cx matrix_trace commutator anticommutator vector_diag matrix_diag Functions public pure function identity (n) result(R) Constructs an n×n identity matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Matrix dimension Return Value real(kind=wp),\n  dimension(n,n) Identity matrix [n×n] public pure function matrix_inverse_re (A) result(R) Wrapper for matrix_inverse_cx that allows the procedure to be used for real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹ public pure function matrix_inverse_cx (A) result(R) Invert a square n×n matrix using Gauss-Jordan elimination with partial pivoting.\n In the special case n=2, the inverse is evaluated using a cofactoring algorithm.\n [This implementation is based on Algorithm #2 in \"Efficient matrix inversion via \n Gauss-Jordan elimination and its parallelization\" by E.S. Quintana et al. (1998)] Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹ public pure function matrix_trace (A) result(r) Calculate the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A) public pure function commutator (A, B) result(R) Calculate the commutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A,1),size(A,1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Commutator R = [A,B] public pure function anticommutator (A, B) result(R) Calculate the anticommutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A,1),size(A,1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Anticommutator R = {A,B} public pure function vector_diag (A) result(r) Extract the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A,1),size(A,2))) r = Diag(A) public pure function matrix_diag (A, B) result(R) Construct a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:,:) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A,1)+size(B,1), size(A,2)+size(B,2)) R = Diag(A,B)","tags":"Foundation","loc":"module/matrix_m.html","title":"matrix_m – ​"},{"text":"This module defines the data type 'spin', which represents 2×2 complex matrices in spin space. The module overloads\n common arithmetic operators to work with the new data type, and defines and exports the Pauli matrices as constants.\n To make it easier to interact with common differential equation solvers, which often operate on real state vectors,\n the assignment operator is overloaded in such a way that 'spin' can be easily imported/exported to a real vector(8). Uses math_m Contents Variables pauli0 pauli1 pauli2 pauli3 pauli Interfaces inverse trace sum conjg norm2 Derived Types spin Variables Type Visibility Attributes Name Initial type( spin ), public, parameter :: pauli0 = spin(reshape([(1, 0), (0, 0), (0, 0), (1, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter :: pauli1 = spin(reshape([(0, 0), (1, 0), (1, 0), (0, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter :: pauli2 = spin(reshape([(0, 0), (0, -1), (0, 1), (0, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter :: pauli3 = spin(reshape([(1, 0), (0, 0), (0, 0), (-1, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter, dimension(0:3) :: pauli = [pauli0, pauli1, pauli2, pauli3] Interfaces public interface inverse Matrix inverse private pure function spin_inv(this) result(r) Calculate the inverse of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin ) public interface trace Matrix trace private pure elemental function spin_trace(this) result(r) Calculate the trace of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value complex(kind=wp) public interface sum Matrix sum private pure function spin_sum(this) result(r) Calculate the sum of an array of spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this (:) Return Value type( spin ) public interface conjg Complex conjugation private pure elemental function spin_conjg(this) result(r) Calculate the complex conjugate of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin ) public interface norm2 Matrix norm private pure elemental function spin_norm(this) result(r) Calculate the Frobenius norm of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value real(kind=wp) Derived Types type, public :: spin Components Type Visibility Attributes Name Initial complex(kind=wp), public :: matrix (2,2) = 0.0_wp Encapsulate a spin matrix Type-Bound Procedures generic, public :: spin => cons_rscalar, cons_cscalar, cons_cmatrix, cons_rvector, cons_spin generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assr_rvector, assl_cmatrix, assl_rvector generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_spin generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_spin generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_spin generic, public :: operator(/) => divr_rscalar, divr_cscalar generic, public :: operator(**) => expr_iscalar","tags":"Foundation","loc":"module/spin_m.html","title":"spin_m – ​"},{"text":"This file provides a common interface to a large library of mathematical\n functions and subroutines. See the documentation of individual interfaces\n below for more information about the contents of the mathematical library. Uses basic_m calculus_m matrix_m Contents Interfaces trace inverse diag mean differentiate integrate interpolate linspace Interfaces public interface trace Public interface for functions that calculate a matrix trace. public pure function matrix_trace (A) result(r) Calculate the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A) public interface inverse Public interface for functions that calculate a matrix inverse. public pure function matrix_inverse_re (A) result(R) Wrapper for matrix_inverse_cx that allows the procedure to be used for real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹ public pure function matrix_inverse_cx (A) result(R) Invert a square n×n matrix using Gauss-Jordan elimination with partial pivoting.\n In the special case n=2, the inverse is evaluated using a cofactoring algorithm.\n [This implementation is based on Algorithm #2 in \"Efficient matrix inversion via \n Gauss-Jordan elimination and its parallelization\" by E.S. Quintana et al. (1998)] Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A,1),size(A,1)) Matrix R=A¯¹ public interface diag Public interface for functions that deal with matrix diagonals. public pure function matrix_diag (A, B) result(R) Construct a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:,:) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A,1)+size(B,1), size(A,2)+size(B,2)) R = Diag(A,B) public pure function vector_diag (A) result(r) Extract the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:,:) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A,1),size(A,2))) r = Diag(A) public interface mean Public interface for routines that calculate the mean value. public pure function mean_array_re (x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value public pure function mean_array_cx (x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value public interface differentiate Public interface for various differentiation routines. public pure function differentiate_array_re (x, y) result(r) This function calculates the numerical derivative of an array y with respect to x, using a central difference approximation\n at the interior points and forward/backward difference approximations at the exterior points. Note that since all the three\n approaches yield two-point approximations of the derivative, the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function differentiate_array_cx (x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx public interface integrate Public interface for various integration routines. public pure function integrate_array_re (x, y) result(r) This function calculates the integral of an array y with respect to x using a trapezoid\n approximation. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx public pure function integrate_array_cx (x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx public function integrate_range_re (x, y, a, b) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on\n discrete numerical data, and subsequently evaluates the integral of the interpolation in the\n range (a,b). Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx public function integrate_range_cx (x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx public interface interpolate Public interface for various interpolation routines. public function interpolate_point_re (x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp) Interpolation result y(p) public function interpolate_point_cx (x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value complex(kind=wp) Interpolation result y(p) public function interpolate_array_re (x, y, p) result(r) This function constructs a piecewise hermitian cubic interpolation of an array y(x) based on discrete numerical data,\n and evaluates the interpolation at points p. Note that the mesh spacing of x does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation result y(p) public function interpolate_array_cx (x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Interpolation domain p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation result y(p) public pure function interpolate_point_matrix_re (x, y, p) result(r) Perform a Piecewise Cubic Hermitian Interpolation of a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:,:,:) :: y Function y(x) real(kind=wp), intent(in) :: p Interpolation point p Return Value real(kind=wp),\n  dimension(size(y,1),size(y,2)) Interpolation result y(p) public interface linspace Public interface for routines that initialize arrays. public pure subroutine linspace_array_re (array, first, last) Populates an existing array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element","tags":"Foundation","loc":"module/math_m.html","title":"math_m – ​"},{"text":"This module defines a data type 'structure', which is useful for constructing and using multilayer hybrid structures. It\n also exports the type definitions and constructors for all class(material) types, although these should rarely be needed. Uses stdio_m condmat_m material_m conductor_m superconductor_m ferromagnet_m halfmetal_m Contents Interfaces structure Derived Types structure Interfaces public interface structure private impure function structure_construct() result(this) Constructs a multilayer stack from a configuration file. Arguments None Return Value type( structure ) Derived Types type, public :: structure Components Type Visibility Attributes Name Initial class( material ), public, pointer :: a => null() First material class( material ), public, pointer :: b => null() Last  material integer, public, allocatable :: supercurrent Output unit (allocate to write supercurrents  to file) integer, public, allocatable :: lossycurrent Output unit (allocate to write lossycurrents  to file) integer, public, allocatable :: accumulation Output unit (allocate to write accumulations  to file) integer, public, allocatable :: correlation Output unit (allocate to write correlations   to file) integer, public, allocatable :: magnetization Output unit (allocate to write magnetizations to file) integer, public, allocatable :: distribution Output unit (allocate to write distributions  to file) integer, public, allocatable :: density Output unit (allocate to write density of states to file) Constructor private impure function structure_construct () Constructs a multilayer stack from a configuration file. Type-Bound Procedures procedure, public :: push => structure_push Construct a single layer procedure, public :: conf => structure_conf Configure a single layer procedure, public :: cmap => structure_cmap Configure  all layers procedure, public :: fmap => structure_fmap Manipulate all layers procedure, public :: initialize => structure_initialize Reset the physical state procedure, public :: save => structure_save Save the physical state procedure, public :: load => structure_load Load the physical state procedure, public :: update => structure_update Update the physical state procedure, public :: update_prehook => structure_update_prehook Execute all update prehooks procedure, public :: update_posthook => structure_update_posthook Execute all update posthooks procedure, public :: converge => structure_converge Update until convergence procedure, public :: write => structure_write Write out observables procedure, public :: difference => structure_difference Check how much the physical state changes procedure, public :: materials => structure_materials Check the number of enabled materials procedure, public :: selfconsistency => structure_selfconsistency Whether selfconsistency iteration is required procedure, public :: superconductors => structure_superconductors Check the number of enables superconductors procedure, public :: chargeviolation => structure_chargeviolation Check the violation of charge conservation procedure, public :: gap => structure_gap Check the minimum superconducting gap","tags":"Materials","loc":"module/structure_m.html","title":"structure_m – ​"},{"text":"This submodule is included by conductor.f, and contains the equations which model spin-active interfaces. Todo Reimplement shortcut-evaluation of the current for nonmagnetic interfaces. Uses propagator_m material_m condmat_m Contents Derived Types spinactive Derived Types type, public :: spinactive Components Type Visibility Attributes Name Initial real(kind=wp), public :: conductance = 1.0 Interfacial conductance real(kind=wp), public :: polarization = 0.0 Interfacial spin-polarization real(kind=wp), public :: spinmixing = 0.0 Interfacial 1st-order spin-mixing real(kind=wp), public :: secondorder = 0.0 Interfacial 2nd-order spin-mixing real(kind=wp), public, dimension(1:3) :: magnetization = [0, 0, 1] Interfacial magnetization direction real(kind=wp), public, dimension(1:3) :: misalignment0 = [0, 0, 0] Interfacial magnetization misalignment (this  side) real(kind=wp), public, dimension(1:3) :: misalignment1 = [0, 0, 0] Interfacial magnetization misalignment (other side) Type-Bound Procedures procedure, public :: diffusion_current => spinactive_diffusion_current procedure, public :: kinetic_current => spinactive_kinetic_current procedure, public :: update_prehook => spinactive_update_prehook","tags":"Materials","loc":"module/spinactive_m.html","title":"spinactive_m – ​"},{"text":"This module defines the data type 'superconductor', which models the physical state of a superconductor. The type is\n a member of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. Uses stdio_m condmat_m conductor_m ferromagnet_m Contents Derived Types superconductor Derived Types type, public, extends( ferromagnet ) :: superconductor Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) real(kind=wp), public, allocatable :: zeeman How easy the material is magnetized by spin accumulation real(kind=wp), public, allocatable :: exchange (:,:) Magnetic exchange field as a function of position complex(kind=wp), public, allocatable :: gap_history (:,:) Superconducting order parameter as a function of location (backup of previously calculated gaps on the location mesh) complex(kind=wp), public, allocatable :: gap_function (:) Superconducting order parameter as a function of location (relative to the zero-temperature gap of a bulk superconductor) real(kind=wp), public, allocatable :: gap_location (:) Location array for the gap function (required because we interpolate the gap to a higher resolution than the propagators) Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: construct => superconductor_construct Construct  propagators procedure, public :: initialize => superconductor_initialize Initialize propagators procedure, public :: diffusion_equation => superconductor_diffusion_equation Diffusion equation procedure, public :: kinetic_equation => superconductor_kinetic_equation Kinetic equation procedure, public :: update_gap => superconductor_update_gap Calculate the superconducting order parameter procedure, public :: update_boost => superconductor_update_boost Boost the convergence of the order parameter (Steffensen's method) procedure, public :: update_prehook => superconductor_update_prehook Update the internal variables before calculating the propagators procedure, public :: update_posthook => superconductor_update_posthook Update the superconducting order parameter from  the propagators procedure, public :: gap => superconductor_gap Return the superconducting order parameter at a given position procedure, public :: conf => superconductor_conf Configure material parameters","tags":"Materials","loc":"module/superconductor_m.html","title":"superconductor_m – ​"},{"text":"This module defines the data type 'ferromagnet', which models the physical state of a ferromagnet. The type is a\n member of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. Uses stdio_m condmat_m conductor_m Contents Derived Types ferromagnet Derived Types type, public, extends( conductor ) :: ferromagnet Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) real(kind=wp), public, allocatable :: zeeman How easy the material is magnetized by spin accumulation real(kind=wp), public, allocatable :: exchange (:,:) Magnetic exchange field as a function of position Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: construct => conductor_construct Constructs the object procedure, public :: initialize => conductor_initialize Initializes propagators procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: update_prehook => ferromagnet_update_prehook Code to execute before calculating the propagators procedure, public :: diffusion_equation => ferromagnet_diffusion_equation Diffusion equation procedure, public :: kinetic_equation => ferromagnet_kinetic_equation Kinetic equation procedure, public :: conf => ferromagnet_conf Configures material parameters","tags":"Materials","loc":"module/ferromagnet_m.html","title":"ferromagnet_m – ​"},{"text":"This module defines the data type 'halfmetal', which models the physical state of a strong or halfmetallic ferromagnet.\n The type is a member of class(conductor), and inherits the internal structure and generic methods defined there. Todo Add an update_posthook to rescale density(:) and current(:) with the dependence of the diffusion constant matrix\n   on the polarization. Remember to check how the polarization dependence varies with the number of dimensions. Todo Check if a non-linear dependence of the polarization matrix on the polarization is more sensible? Uses stdio_m condmat_m material_m conductor_m Contents Derived Types halfmetal Derived Types type, public, extends( conductor ) :: halfmetal Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) real(kind=wp), public :: polarization = 0.0_wp Spin-polarization of the ferromagnet Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: construct => conductor_construct Constructs the object procedure, public :: initialize => conductor_initialize Initializes propagators procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: conf => halfmetal_conf Configures the material parameters procedure, public :: diffusion_equation => halfmetal_diffusion_equation Defines the Usadel diffusion equation procedure, public :: diffusion_equation_a => halfmetal_diffusion_equation_a Boundary condition at the left  interface procedure, public :: diffusion_equation_b => halfmetal_diffusion_equation_b Boundary condition at the right interface procedure, public :: update_prehook => halfmetal_update_prehook Code to execute before calculating the propagators procedure, public :: update_posthook => halfmetal_update_posthook Code to execute after  calculating the propagators procedure, public :: update_density => halfmetal_update_density Calculates the density of states","tags":"Materials","loc":"module/halfmetal_m.html","title":"halfmetal_m – ​"},{"text":"This module defines the data type 'conductor', which models the physical state of a conductor for a discretized range\n of positions and energies.  It has two main applications: (i) it can be used as a base type for more exotic materials,\n such as superconductors and ferromagnets; (ii) it can be used in conjunction with such materials in hybrid structures. Uses stdio_m condmat_m material_m spinorbit_m spinactive_m spinscattering_m Contents Derived Types conductor Derived Types type, public, extends( material ) :: conductor Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material type( spinscattering ), public, allocatable :: spinscattering Spin-dependent scattering type( spinorbit ), public, allocatable :: spinorbit Spin-orbit coupling type( spinactive ), public, allocatable :: spinactive_a Spin-active interface (left) type( spinactive ), public, allocatable :: spinactive_b Spin-active interface (right) Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: construct => conductor_construct Constructs the object procedure, public :: initialize => conductor_initialize Initializes propagators procedure, public :: update_prehook => conductor_update_prehook Code to execute before updates procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates procedure, public :: diffusion_equation => conductor_diffusion_equation Diffusion equation procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: conf => conductor_conf Configures material parameters","tags":"Materials","loc":"module/conductor_m.html","title":"conductor_m – ​"},{"text":"This submodule is included by conductor.f, and contains the equations which model spin-orbit coupling in diffusive materials. Uses condmat_m material_m Contents Interfaces spinorbit Derived Types spinorbit Functions spinorbit_construct Interfaces public interface spinorbit public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit ) Derived Types type, public :: spinorbit Components Type Visibility Attributes Name Initial class( material ), public, pointer :: material => null() Pointer to the material modelled by this instance type(spin), public, dimension(1:3) :: field Spin-orbit coupling field (SU(2) gauge field) type(spin), public :: Ax Spin-orbit coupling matrices (the components and square) type(spin), public :: Ay Spin-orbit coupling matrices (the components and square) type(spin), public :: Az Spin-orbit coupling matrices (the components and square) type(spin), public :: A2 Spin-orbit coupling matrices (the components and square) type(spin), public :: Axt Spin-orbit coupling matrices (tilde-conjugated versions) type(spin), public :: Ayt Spin-orbit coupling matrices (tilde-conjugated versions) type(spin), public :: Azt Spin-orbit coupling matrices (tilde-conjugated versions) type(spin), public :: A2t Spin-orbit coupling matrices (tilde-conjugated versions) Constructor public  function spinorbit_construct (parent) Constructs a spinorbit object with a given parent material. Type-Bound Procedures procedure, public :: diffusion_equation => spinorbit_diffusion_equation Diffusion equation procedure, public :: diffusion_equation_a => spinorbit_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => spinorbit_diffusion_equation_b Boundary condition (right) procedure, public :: update_prehook => spinorbit_update_prehook Code to execute before updates Functions public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit )","tags":"Materials","loc":"module/spinorbit_m.html","title":"spinorbit_m – ​"},{"text":"This module defines the data type 'material',  which models the state of a physical material for a discretized range of\n positions and energies. This is an abstract type, meaning that it is not intended to be instantiated on its own, but is\n intended as a base type for physical materials like conductors, superconductors, and ferromagnets. In other words, this\n type defines the essential data structures and program structure, while the derived subtypes will define actual physics. Uses stdio_m condmat_m Contents Derived Types material Subroutines material_conf material_load Derived Types type, public, abstract :: material Components Type Visibility Attributes Name Initial real(kind=wp), public :: length = 1.00_wp Material length (L/ξ) real(kind=wp), public :: thouless = 1.00_wp Thouless energy (ħD/L²) real(kind=wp), public :: scattering = 0.01_wp Inelastic scattering (η/Δ₀) logical, public :: transparent_a = .false. Interface transparency (left) logical, public :: transparent_b = .false. Interface transparency (right) logical, public :: phaselock = .false. Lock the center-of-mass phase? logical, public :: equilibrium = .true. Equilibrium? logical, public :: transverse = .false. Transverse potential gradients? real(kind=wp), public :: voltage = 0.00_wp Voltage (eV/Δ₀) real(kind=wp), public :: temperature = 0.01_wp Temperature (T/Tc) real(kind=wp), public :: spinvoltage = 0.00_wp Spin-voltage (eVs/Δ₀) real(kind=wp), public :: spintemperature = 0.00_wp Spin-temperature (Ts/Tc) real(kind=wp), public, dimension(1:3) :: spinaxis = [0, 0, 1] Spin quantization axis real(kind=wp), public, allocatable :: energy (:) Energy domain real(kind=wp), public, allocatable :: location (:) Position domain type(propagator), public, allocatable :: propagator (:,:) Propagator values type(propagator), public, allocatable :: backup (:,:) Propagator backups real(kind=wp), public, allocatable :: density (:,:,:) Spin-resolved density of states real(kind=wp), public, allocatable :: supercurrent (:,:) Charge, spin, heat, and spin-heat supercurrents real(kind=wp), public, allocatable :: lossycurrent (:,:) Charge, spin, heat, and spin-heat dissipative currents real(kind=wp), public, allocatable :: accumulation (:,:) Charge, spin, heat, and spin-heat accumulation real(kind=wp), public, allocatable :: magnetization (:,:) Magnetization due to exchange and Zeeman effects complex(kind=wp), public, allocatable :: correlation (:) Superconducting pair-correlations integer, public :: order = 1 Simulation priority of this material class( material ), public, pointer :: material_a => null() Material to the left  (default: vacuum) class( material ), public, pointer :: material_b => null() Material to the right (default: vacuum) integer, public :: iteration = 0 Used to keep track of selfconsistent iteration cycles integer, public :: selfconsistency = 2 Selfconsistency scheme (0 = none, 1 = fixpoint, 2 = boost) integer, public :: scaling = 128 Maximal mesh increase (range: 2&#94;N, N>1) integer, public :: method = 4 Runge—Kutta order (range: 2, 4, 6) integer, public :: control = 2 Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real(kind=wp), public :: tolerance = 1e-10_wp Error tolerance (maximum defect or global error) integer, public :: information = 0 Debug information (range: [-1,2]) real(kind=wp), public :: difference = 1e+10_wp Difference between iterations character(len=128), public :: type_string = 'MATERIAL' Name of this material Type-Bound Procedures procedure(manipulate), public :: construct Construct  object procedure(initialize), public :: initialize Initialize object procedure(manipulate), public :: update_prehook Executed before update procedure(manipulate), public :: update_posthook Executed after  update procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure(diffusion_equation), public :: diffusion_equation Diffusion equation procedure(diffusion_equation_a), public :: diffusion_equation_a Boundary condition (left) procedure(diffusion_equation_b), public :: diffusion_equation_b Boundary condition (right) procedure(kinetic_equation), public :: kinetic_equation Kinetic equation procedure(kinetic_equation_a), public :: kinetic_equation_a Boundary condition (left) procedure(kinetic_equation_b), public :: kinetic_equation_b Boundary condition (right) procedure, public :: conf => material_conf Configures material parameters procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material Subroutines public impure subroutine material_conf (this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this character(len=*), intent(in) :: key character(len=*), intent(in) :: val public impure subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this","tags":"Materials","loc":"module/material_m.html","title":"material_m – ​"},{"text":"This submodule is included by conductor.f, and contains equations which model \n spin-flip scattering, spin-orbit scattering, and magnetic orbital depairing. Uses condmat_m material_m Contents Interfaces spinscattering Derived Types spinscattering Functions spinscattering_construct Interfaces public interface spinscattering public impure function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering ) Derived Types type, public :: spinscattering Components Type Visibility Attributes Name Initial class( material ), public, pointer :: material => null() Pointer to the material modelled by this instance type(nambu), public, dimension(0:7) :: nambuv Pauli matrices spanning the 4×4 Spin-Nambu space real(kind=wp), public :: depairing = 0.0_wp Orbital depairing coefficient real(kind=wp), public :: spinflip = 0.0_wp Spin-flip  scattering coefficient (1/8τΔ) real(kind=wp), public :: spinorbit = 0.0_wp Spin-orbit scattering coefficient (1/8τΔ) Constructor public impure function spinscattering_construct (parent) Constructs a spinscattering object with a given parent material. Type-Bound Procedures procedure, public :: diffusion_equation => spinscattering_diffusion_equation Diffusion equation procedure, public :: kinetic_equation => spinscattering_kinetic_equation Kinetic equation Functions public impure function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering )","tags":"Materials","loc":"module/spinscattering_m.html","title":"spinscattering_m – ​"},{"text":"Uses structure_m stdio_m math_m This program calculates the current-voltage relation of a one-dimensional superconducting structure. Contents Variables stack na nb threshold tolerance iterations voltage current n Subroutines prehook posthook finalize Variables Type Attributes Name Initial type( structure ) :: stack type( conductor ), target :: na type( conductor ), target :: nb real(kind=wp), parameter :: threshold = 1e-2 real(kind=wp), parameter :: tolerance = 1e-5 integer, parameter :: iterations = 100 real(kind=wp), dimension(:), allocatable :: voltage real(kind=wp), dimension(:), allocatable :: current integer :: n Subroutines impure subroutine prehook () Arguments None impure subroutine posthook () Arguments None impure subroutine finalize () Arguments None","tags":"Programs","loc":"program/voltage_p.html","title":"voltage_p – ​"},{"text":"Uses structure_m stdio_m math_m This program calculates the phase-diagram of a one-dimensional superconducting structure. Contents Variables stack bootstraps iterations threshold flow init Subroutines prehook finalize Variables Type Attributes Name Initial type( structure ) :: stack integer, parameter :: bootstraps = 10 integer, parameter :: iterations = 10 real(kind=wp), parameter :: threshold = 1e-8_wp real(kind=wp) :: flow real(kind=wp) :: init Subroutines impure subroutine prehook () Arguments None impure subroutine finalize () Arguments None","tags":"Programs","loc":"program/phase_p.html","title":"phase_p – ​"},{"text":"Uses structure_m stdio_m math_m This program calculates steady-state observables in a one-dimensional superconducting structure. Contents Variables stack threshold tolerance Subroutines finalize Variables Type Attributes Name Initial type( structure ) :: stack real(kind=wp), parameter :: threshold = 1e-2 real(kind=wp), parameter :: tolerance = 1e-8 Subroutines impure subroutine finalize () Arguments None","tags":"Programs","loc":"program/converge_p.html","title":"converge_p – ​"},{"text":"Uses structure_m stdio_m math_m This program calculates the critical temperature of a one-dimensional superconducting structure. Contents Variables stack bisections bootstraps iterations threshold initgap minimum maximum critical n Subroutines prehook finalize Variables Type Attributes Name Initial type( structure ) :: stack integer, parameter :: bisections = 20 integer, parameter :: bootstraps = 10 integer, parameter :: iterations = 10 real(kind=wp), parameter :: threshold = 1e-08_wp real(kind=wp), parameter :: initgap = 1e-02_wp real(kind=wp) :: minimum = 0.00_wp real(kind=wp) :: maximum = 1.00_wp real(kind=wp) :: critical = 0.50_wp integer :: n = 0 Subroutines impure subroutine prehook () Arguments None impure subroutine finalize () Arguments None","tags":"Programs","loc":"program/critical_p.html","title":"critical_p – ​"},{"text":"Uses structure_m stdio_m math_m This program calculates the current-phase relation of a one-dimensional superconducting structure. Contents Variables stack sa sb threshold tolerance iterations phase current critical n m Subroutines prehook posthook finalize Variables Type Attributes Name Initial type( structure ) :: stack type( superconductor ), target :: sa type( superconductor ), target :: sb real(kind=wp), parameter :: threshold = 1e-2 real(kind=wp), parameter :: tolerance = 1e-8 integer, parameter :: iterations = 51 real(kind=wp), dimension(:), allocatable :: phase real(kind=wp), dimension(:), allocatable :: current real(kind=wp) :: critical integer :: n integer :: m Subroutines impure subroutine prehook () Arguments None impure subroutine posthook () Arguments None impure subroutine finalize () Arguments None","tags":"Programs","loc":"program/phase_p~2.html","title":"phase_p – ​"},{"text":"Note The documentation is incomplete, and parts of it are out-of-date.\n      The plan is to amend it with a discussion of the configuration file format as well as some example programs as soon as possible. This is a set of numerical programs for solving the Usadel diffusion equation in one-dimensional superconducting nanostructures, both in and out of equilibrium.\nThe programs are quite flexible, being able to treat systems with e.g. magnetic elements, spin-orbit coupling, spin-flip scattering, spin-orbit scattering, strongly polarized magnetic interfaces, voltage gradients, and temperature gradients.\nThe suite also contains specialized programs for calculating the critical temperature and phase diagrams of all these hybrid structures.\nThe programs are also built to be user-friendly: they are configured using simple configuration files, which can include mathematical expressions to initialize the physical system, and the output files are easily imported in e.g. Gnuplot or Matlab.\nFinally, the code is written in modern object-oriented Fortran, making it both simple and efficient. This software was developed by Jabir Ali Ouassou during his doctoral research.\nThe research was supervised by Prof. Jacob Linder at the Center for Quantum Spintronics , NTNU, Norway.\nThe software itself is released under the MIT open-source licence ;\nthis basically means that you are free to use it for any purpose, as long as you give credit where appropriate.\nThe source is available on Github . The project also relies on the external libraries bvp_solver , fparser , and pchip .\nThese are available under a mixture of open-source licences, as indicated in the source files themselves.\nFor convenience, these libraries have been bundled with this software page, and their sources are located under src/external . You should start by checking if your system satisfies the list of dependencies , and then move on to the compilation instructions .\nAfter that, you can learn about the format of the configuration files used to describe relevant physical systems here , and about each particular program in the suite here .","tags":"","loc":"page//index.html","title":"Overview – ​"},{"text":"To compile the project, any Fortran compiler that supports the official language standards from 1977 through 2008 should suffice.\nHowever, the software has been developed and tested using the compilers below.\nFor your own convenience, it is therefore recommended that you have the following available: CMake :\n   an open-source cross-platform build system that automates the compilation details; GFortran :\n   an open-source cross-platform Fortran compiler from the GNU Compiler Collection; IFort :\n   a commercial Fortran compiler developed by Intel, with free licenses for e.g. students . The code was last tested using GFortran 8.2.0, IFort 18.0.2, and CMake 3.10.2.\nNewer versions should probably work fine, while older versions may or may not work.\nThe software was originally developed using GFortran 5.0 and CMake 2.6, and later tested rigorously with IFort 16.0.\nHowever, newer versions of the software increasingly relies on modern language features, which may be unavailable or unreliable on older compilers. In my experience, IFort generates much faster binaries than GFortran:\nwith the most aggressive optimalization settings, IFort binaries run ~4x faster on an Intel Core i7.\nFurthermore, the nonequilibrium functionality in particular has been tested more rigorously using IFort.\nHowever, if you do not have access to IFort, the code should work fine with GFortran too, so no proprietary tools are strictly required. Although slower, the binaries generated by GFortran can sometimes be more stable than the ones generated by IFort.\nIn most cases, this is just caused by IFort choosing to place more variables on the stack than GFortran.\nIn that case, the problem can be resolved by running the command ulimit -s unlimited to increase the stack size, assuming that you use a Linux/Unix system with a Bourne-based shell. There are also some optional but recommended programs: This documentation was automatically generated by FORD , based on the source code and some supplementary Markdown files.\n   This program should be installed if you plan to modify the source code, and wish to automatically update the documentation accordingly. The output formats are designed to be easy to plot with Gnuplot .\n   For examples of how to generate publication-quality plots with Gnuplot, see e.g. this page .\n   However, it should also be straight-forward to import the generated data to e.g. Matlab, Python, or R, if you prefer that.","tags":"","loc":"page/./01-dependencies.html","title":"Dependencies – ​"},{"text":"Note These instructions should work for Unix-like operating systems with all the recommended dependencies installed.\n  This should include Linux/Unix/Mac systems, and possibly also Windows if you have e.g. Cygwin installed. \n  If you use other platforms or compilers, you may have to compile the project manually. After downloading the source code, open a terminal, and go to the top directory of the project.\nThis should be the directory with the files configure and CMakeLists.txt .\nTo prepare for compilation, you should then run one of the following commands, depending on whether you wish to compile with GFortran or IFort: ./configure --gfortran\n./configure --ifort If you need to search for bugs, it can be quite useful to enable debug mode.\nThis essentially means that all compiler optimizations are disabled, and extra safety checks are performed at both compiletime and runtime.\nAs a consequence, the generated code will run several times slower, but will also provide better feedback if something goes wrong.\nTo enable debug mode, run one of these commands instead of the above: ./configure --gfortran-debug\n./configure --ifort-debug After configuration, change to the subdirectory build , and run make to compile: cd build\nmake -j4 If the project compiles successfully, the executables should appear in the subdirectory bin of the top directory. \nYou might want to add that directory to your system PATH variable, or move the executables to a system location like /usr/local/bin/ , so that the programs can be run without specifying a full path. This documentation has been automatically generated using FORD .\nIf you modify the source code, and wish to update the documentation accordingly, run the following command: ./configure --docs","tags":"","loc":"page/./02-compilation.html","title":"Compilation – ​"},{"text":"The programs equilibrium , critical_temperature , and critical_current all require a configuration file materials.conf to run.","tags":"","loc":"page/03-config/index.html","title":"Configuration files – ​"},{"text":"Conductor-specific options.","tags":"","loc":"page/03-config/conductor.html","title":"Conductor – ​"},{"text":"Ferromagnet-specific options.","tags":"","loc":"page/03-config/ferromagnet.html","title":"Ferromagnet – ​"},{"text":"Halfmetal-specific options.","tags":"","loc":"page/03-config/halfmetal.html","title":"Halfmetal – ​"},{"text":"Superconductor-specific options.","tags":"","loc":"page/03-config/superconductor.html","title":"Superconductor – ​"},{"text":"List of programs. Equilibrium properties This program does something. Fill in details. ./bin/equilibrium Critical temperature This program does something. Fill in details. ./bin/temperature Critical current This program does something. Fill in details. ./bin/current","tags":"","loc":"page/04-programs/index.html","title":"Programs – ​"},{"text":"This program does something. Fill in details. ./bin/current Note This program should only be used if you either (i) need to determine the critical current,\n  precisely, or (ii) need to map the entire current-phase relation. If you just want to find\n  the currents in a Josephson junction for some given phase difference (e.g. π/2), it is much \n  more efficient to execute the equilibrium program with locked superconductors at the edges.","tags":"","loc":"page/04-programs/current.html","title":"Current – ​"},{"text":"This program does something. Fill in details. ./bin/equilibrium The boundary value problem solver used internally by the material objects works by starting with\nan initial guess for what the solution should look like, and then tries to locally minimize the\nimplicit differential equations to find the proper solution. The better the initial guess is, the\nbetter able the boundary value problem solver is to find a proper solution. By default, initial\nstates of all regular materials are set to BCS superconducting states, while the initial states\nof halfmetallic ferromagnets are set to normal metallic states. However, for many multi-layer\nstructures, these are quite bad initial guesses. One workaround is to then start with a very\nfaint superconducting gap in the structure, and let it selfconsistently tend to the real one. But for tough problems, you should use bootstrap binary instead.","tags":"","loc":"page/04-programs/equilibrium.html","title":"Equilibrium – ​"},{"text":"This program does something. Fill in details. ./bin/temperature","tags":"","loc":"page/04-programs/temperature.html","title":"Temperature – ​"},{"text":"Before running any serious simulations, you may wish to run the unit tests.\nFrom the top directory of the project, this can be done by invoking the\nexecutable test in the subdirectory bin : ./bin/test Except for the calibration procedure, all unit tests should return SUCCESS .","tags":"","loc":"page/04-programs/test.html","title":"Unit tests – ​"},{"text":"All data files produced by the simulations are exported as numerical tables\nin a simple tab-delimited text file, with the top row documenting the output\nformat. These results should be easy to import and plot in any common plotting\nenvironment. If you have Gnuplot on your system, then you can\nalso reuse my existing plotting scripts to display the output data: ./bin/disp filename.dat","tags":"","loc":"page/./05-data.html","title":"Data files – ​"}]}